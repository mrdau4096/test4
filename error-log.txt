/Log file for any reported errors. Any errors will appear below;
14:39:32, 24-04-2024 / ERROR in main.py, init() / inconsistent use of tabs and spaces in indentation (physics.py, line 197)
14:40:15, 24-04-2024 / ERROR in main.py, init() / inconsistent use of tabs and spaces in indentation (physics.py, line 197)
14:40:44, 24-04-2024 / ERROR in main.py, init() / inconsistent use of tabs and spaces in indentation (physics.py, line 197)
14:43:34, 24-04-2024 / ERROR in main.py, init() / inconsistent use of tabs and spaces in indentation (physics.py, line 164)
14:56:08, 24-04-2024 / ERROR in main.py, init() / invalid syntax. Perhaps you forgot a comma? (physics.py, line 80)
14:56:30, 24-04-2024 / ERROR in main.py, init() / invalid syntax. Perhaps you forgot a comma? (physics.py, line 80)
15:00:09, 24-04-2024 / ERROR in main.py, init() / '(' was never closed (physics.py, line 81)
15:00:30, 24-04-2024 / ERROR in main.py, init() / inconsistent use of tabs and spaces in indentation (physics.py, line 89)
15:11:27, 24-04-2024 / ERROR in main.py, init() / inconsistent use of tabs and spaces in indentation (physics.py, line 57)
11:18:04, 26-04-2024 / ERROR in main.py, init() / inconsistent use of tabs and spaces in indentation (physics.py, line 217)
11:21:02, 26-04-2024 / ERROR in main.py, init() / unmatched ')' (physics.py, line 75)
11:04:37, 28-04-2024 / ERROR in main.py, init() / str expected, not int
16:59:13, 30-04-2024 / ERROR in main.py, init() / can only be called with ndarray object
21:52:53, 18-06-2024 / ERROR in Mainloop / No module named 'PIL'
21:53:54, 18-06-2024 / ERROR in Mainloop / No module named 'PIL'
21:55:19, 18-06-2024 / ERROR in Mainloop / No module named 'PIL'
22:01:09, 18-06-2024 / ERROR in main.init / No module named 'PIL'
22:01:14, 18-06-2024 / ERROR in Mainloop / name 'RUN' is not defined
22:02:06, 18-06-2024 / ERROR in main.init / name 'Image' is not defined
22:02:09, 18-06-2024 / ERROR in Mainloop / name 'RUN' is not defined
12:33:07, 24-06-2024 / ERROR in physics.UPDATE_PHYSICS / name 'QUAD_STATIC' is not defined
12:33:23, 24-06-2024 / ERROR in physics.UPDATE_PHYSICS / name 'QUAD_STATIC' is not defined
12:33:44, 24-06-2024 / ERROR in physics.UPDATE_PHYSICS / name 'QUAD_STATIC' is not defined
21:57:45, 25-06-2024 / ERROR in main.init / invalid literal for int() with base 10: '0, 0, 0'
13:17:14, 29-06-2024 / ERROR in render.scene / 'TRI' object has no attribute 'NORMALS'
17:30:23, 30-06-2024 / ERROR in Mainloop / name 'Image' is not defined
18:36:54, 30-06-2024 / ERROR in Mainloop / name 'Image' is not defined
20:59:40, 11-07-2024 / ERROR in place / error
23:15:54, 19-07-2024 / ERROR in main.py, init() / module 'exct.utils' has no attribute 'FIND_VECTOR'
23:16:17, 19-07-2024 / ERROR in main.py, init() / module 'exct.utils' has no attribute 'FIND_VECTOR'
16:19:12, 22-07-2024 / ERROR in main.py, init() / invalid syntax (physics.py, line 276)
16:19:16, 22-07-2024 / ERROR in main.py, init() / invalid syntax (physics.py, line 276)
16:19:19, 22-07-2024 / ERROR in main.py, init() / invalid syntax (physics.py, line 276)
16:29:53, 22-07-2024 / ERROR in main.py, init() / invalid syntax (physics.py, line 231)
17:02:03, 22-07-2024 / ERROR in main.py, init() / inconsistent use of tabs and spaces in indentation (physics.py, line 275)
22:07:37, 25-07-2024 / ERROR in main.py, init() / No module named 'pyrr'
22:07:45, 25-07-2024 / ERROR in main.py, init() / No module named 'pyrr'
20:24:00, 12-08-2024 / ERROR in Mainloop / ('Shader compile failure (0): b\'0(10) : error C1503: undefined variable "texCoords"\\n\'', [b'#version 330 core\nlayout(location = 0) in vec3 Position;\nlayout(location = 1) in vec2 TexCoords;\n\nout vec2 fragTexCoords;\n\nvoid main()\n{\n\t//Basic vertex shader for the UI quads.\n\tfragTexCoords = texCoords;\n\tgl_Position = vec4(Position, 1.0);\n}'], GL_VERTEX_SHADER)
20:25:28, 12-08-2024 / ERROR in Mainloop / ('Shader compile failure (0): b\'0(10) : error C1503: undefined variable "texCoords"\\n\'', [b'#version 330 core\nlayout(location = 0) in vec3 Position;\nlayout(location = 1) in vec2 TexCoords;\n\nout vec2 fragTexCoords;\n\nvoid main()\n{\n\t//Basic vertex shader for the UI quads.\n\tfragTexCoords = texCoords;\n\tgl_Position = vec4(Position, 1.0);\n}'], GL_VERTEX_SHADER)
20:26:05, 12-08-2024 / ERROR in Mainloop / exception: access violation reading 0x0000018EE9794000
07:21:13, 13-08-2024 / ERROR in main.py / Initial imports failed.
07:27:23, 13-08-2024 / ERROR in main.py / Initial imports failed.
07:29:03, 13-08-2024 / ERROR in main.py / Initial imports failed.
07:31:01, 13-08-2024 / ERROR in main.py / Initial imports failed.
07:32:41, 13-08-2024 / ERROR in main.py / Initial imports failed.
07:34:21, 13-08-2024 / ERROR in main.py / Initial imports failed.
07:38:45, 13-08-2024 / ERROR in main.py / Initial imports failed.
07:40:24, 13-08-2024 / ERROR in main.py / Initial imports failed.
07:42:08, 13-08-2024 / ERROR in main.py / Initial imports failed.
08:15:51, 13-08-2024 / ERROR in Mainloop / name 'quit' is not defined
08:23:05, 13-08-2024 / ERROR in Mainloop / exception: access violation reading 0x0000010AD236F000
20:45:39, 14-08-2024 / ERROR in Mainloop / name 'sin' is not defined
21:39:07, 14-08-2024 / ERROR in main.py / IsNotMain
20:15:46, 17-08-2024 / ERROR in Mainloop / too many values to unpack (expected 4)
14:49:22, 27-08-2024 / ERROR in physics.UPDATE_PHYSICS / 'CUBE_PATH' object has no attribute 'TEXTURE_DATA'
14:50:08, 27-08-2024 / ERROR in physics.UPDATE_PHYSICS / 'CUBE_PATH' object has no attribute 'BOUNDING_BOX_OBJ'
14:50:22, 27-08-2024 / ERROR in physics.UPDATE_PHYSICS / 'CUBE_PATH' object has no attribute 'ROTATION'
11:53:02, 29-08-2024 / ERROR in physics.UPDATE_PHYSICS / 'tuple' object has no attribute 'PROJECT'
13:12:19, 29-08-2024 / ERROR in main.py / Initial imports failed.
13:14:10, 29-08-2024 / ERROR in main.py / Initial imports failed.
13:16:20, 29-08-2024 / ERROR in main.py / Initial imports failed.
13:18:39, 29-08-2024 / ERROR in main.py / Initial imports failed.
13:34:44, 29-08-2024 / ERROR in main.py / Initial imports failed.
13:35:17, 29-08-2024 / ERROR in main.py / Initial imports failed.
14:46:50, 29-08-2024 / ERROR in texture_load.py / Initial imports failed.
14:48:49, 29-08-2024 / ERROR in ui.py / Initial imports failed.
14:49:56, 29-08-2024 / ERROR in ui.py / Initial imports failed.
14:51:31, 29-08-2024 / ERROR in ui.py / Initial imports failed.
14:52:50, 29-08-2024 / ERROR in ui.py / Initial imports failed.
14:54:35, 29-08-2024 / ERROR in ui.py / Initial imports failed.
14:57:28, 29-08-2024 / ERROR in ui.py / Initial imports failed.
15:00:19, 29-08-2024 / ERROR in ui.py / Initial imports failed.
15:02:48, 29-08-2024 / ERROR in ui.py / Initial imports failed.
15:04:05, 29-08-2024 / ERROR in ui.py / Initial imports failed.
15:05:23, 29-08-2024 / ERROR in ui.py / Initial imports failed.
15:07:31, 29-08-2024 / ERROR in ui.py / Initial imports failed.
15:09:26, 29-08-2024 / ERROR in ui.py / Initial imports failed.
15:10:52, 29-08-2024 / ERROR in ui.py / Initial imports failed.
15:14:31, 29-08-2024 / ERROR in ui.py / Initial imports failed.
15:15:45, 29-08-2024 / ERROR in ui.py / Initial imports failed.
15:16:55, 29-08-2024 / ERROR in ui.py / Initial imports failed.
15:18:23, 29-08-2024 / ERROR in ui.py / Initial imports failed.
15:21:12, 29-08-2024 / ERROR in ui.py / Initial imports failed.
15:22:29, 29-08-2024 / ERROR in Main.py Value initialisation / name 'Matrix44' is not defined
15:23:48, 29-08-2024 / ERROR in utils.py / Initial imports failed.
15:34:28, 29-08-2024 / ERROR in main.py / name 'log' is not defined
18:58:00, 05-09-2024 / ERROR in main.py / No module named 'imgs'
18:58:21, 05-09-2024 / ERROR in texture_load.py / expected ':' (utils.py, line 189)
18:58:54, 05-09-2024 / ERROR in texture_load.py / too many values to unpack (expected 2)
18:59:30, 05-09-2024 / ERROR in texture_load.py / too many values to unpack (expected 2)
18:59:37, 05-09-2024 / ERROR in texture_load.py / too many values to unpack (expected 2)
18:59:53, 05-09-2024 / ERROR in texture_load.py / too many values to unpack (expected 2)
19:00:15, 05-09-2024 / ERROR in texture_load.py / too many values to unpack (expected 2)
19:00:49, 05-09-2024 / ERROR in texture_load.py / too many values to unpack (expected 2)
19:02:17, 05-09-2024 / ERROR in texture_load.py / too many values to unpack (expected 2)
19:02:35, 05-09-2024 / ERROR in texture_load.py / too many values to unpack (expected 2)
19:03:12, 05-09-2024 / ERROR in texture_load.py / too many values to unpack (expected 2)
19:08:17, 05-09-2024 / ERROR in utils.py / [Errno 2] No such file or directory: 'config.dat'
19:08:35, 05-09-2024 / ERROR in render.py / 'str' object has no attribute 'TO_LIST'
19:08:58, 05-09-2024 / ERROR in render.py / 'str' object has no attribute 'TO_LIST'
19:24:10, 05-09-2024 / ERROR in physics.UPDATE_PHYSICS / name 'PG' is not defined
20:24:51, 05-09-2024 / ERROR in main.py / Failed to load GLFW3 shared library.
20:25:48, 05-09-2024 / ERROR in main.py / Failed to load GLFW3 shared library.
20:26:32, 05-09-2024 / ERROR in main.py / Failed to load GLFW3 shared library.
21:08:48, 05-09-2024 / ERROR in main.py / Failed to load GLFW3 shared library.
21:10:44, 05-09-2024 / ERROR in main.py / Failed to load GLFW3 shared library.
21:12:01, 05-09-2024 / ERROR in main.py / Failed to load GLFW3 shared library.
21:16:02, 05-09-2024 / ERROR in utils.py / Initial imports failed.
21:29:48, 05-09-2024 / ERROR in ui.py / No module named 'PIL'
22:14:53, 05-09-2024 / ERROR in ui.py / No module named 'PIL'
17:07:27, 14-09-2024 / ERROR in texture_load.py / unmatched ')' (utils.py, line 834)
18:09:36, 14-09-2024 / ERROR in render.py / cannot import name 'Image' from 'pygame' (C:\Python310\lib\site-packages\pygame\__init__.py)
18:20:15, 14-09-2024 / ERROR in texture_load.py / invalid syntax (utils.py, line 835)
18:20:23, 14-09-2024 / ERROR in texture_load.py / invalid syntax (utils.py, line 835)
18:20:56, 14-09-2024 / ERROR in texture_load.py / invalid syntax (utils.py, line 835)
20:31:45, 14-09-2024 / ERROR in render.py / invalid syntax. Perhaps you forgot a comma? (ui.py, line 104)
11:30:09, 15-09-2024 / ERROR in render.py / invalid syntax (ui.py, line 238)
17:54:10, 15-09-2024 / ERROR in render.py / invalid syntax. Perhaps you forgot a comma? (ui.py, line 259)
19:41:38, 15-09-2024 / ERROR in render.py / invalid syntax (ui.py, line 139)
19:42:04, 15-09-2024 / ERROR in render.py / invalid syntax (ui.py, line 139)
19:42:23, 15-09-2024 / ERROR in render.py / invalid syntax (ui.py, line 139)
14:45:15, 22-09-2024 / ERROR in render.py / No module named 'PIL'
16:35:19, 30-09-2024 / ERROR in render.py / No module named 'PIL'
16:36:27, 30-09-2024 / ERROR in render.py / No module named 'PIL'
16:42:53, 30-09-2024 / ERROR in render.py / No module named 'PIL'
16:43:23, 30-09-2024 / ERROR in render.py / No module named 'PIL'
16:44:14, 30-09-2024 / ERROR in render.py / No module named 'pil'
16:44:20, 30-09-2024 / ERROR in render.py / No module named 'pil'
16:46:31, 30-09-2024 / ERROR in render.py / No module named 'PIL'
16:47:31, 30-09-2024 / ERROR in render.py / No module named 'PIL'
16:51:20, 30-09-2024 / ERROR in render.py / No module named 'PIL'
19:04:33, 30-09-2024 / ERROR in render.py / invalid syntax (ui.py, line 399)
19:06:19, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / invalid destination position for blit
19:10:39, 30-09-2024 / ERROR in render.py / invalid syntax (ui.py, line 57)
20:07:34, 30-09-2024 / ERROR in render.py / name 'DRAW_TEXT' is not defined
20:07:59, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / name 'OPTIONS_MENU_BUTTONS' is not defined
20:08:04, 30-09-2024 / ERROR in render.py / name 'DRAW_TEXT' is not defined
20:08:28, 30-09-2024 / ERROR in render.py / font not initialized
20:08:44, 30-09-2024 / ERROR in render.py / font not initialized
20:09:31, 30-09-2024 / ERROR in render.py / name 'BUTTONS' is not defined
20:10:02, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / name 'OPTIONS_BUTTONS' is not defined
20:10:50, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / 'BACK'
20:11:21, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / 'BACK'
20:11:38, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / 'BACK'
20:33:52, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / 'NoneType' object has no attribute 'append'
20:43:25, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / local variable 'UI_SURFACE' referenced before assignment
20:44:19, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / local variable 'UI_SURFACE' referenced before assignment
20:47:04, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / not enough values to unpack (expected 4, got 1)
20:47:35, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / not enough values to unpack (expected 4, got 1)
20:50:38, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / 'NoneType' object is not iterable
20:50:55, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / object of type 'NoneType' has no len()
20:53:44, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / object of type 'NoneType' has no len()
20:55:07, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / object of type 'NoneType' has no len()
20:55:46, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / local variable 'BUTTON' referenced before assignment
20:55:59, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / 'str' object has no attribute 'EVALUATE_STATE'
20:56:16, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / 'str' object has no attribute 'EVALUATE_STATE'
20:56:31, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / 'str' object has no attribute 'EVALUATE_STATE'
20:56:44, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / 'str' object has no attribute 'EVALUATE_STATE'
20:57:38, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / 'str' object has no attribute 'EVALUATE_STATE'
20:58:06, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / 'str' object has no attribute 'EVALUATE_STATE'
20:59:29, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / 'str' object has no attribute 'EVALUATE_STATE'
21:00:23, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / 'str' object has no attribute 'EVALUATE_STATE'
21:02:22, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / 'str' object has no attribute 'EVALUATE_STATE'
21:06:37, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / 'list' object has no attribute 'EVALUATE_STATE'
21:06:51, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / 'list' object has no attribute 'EVALUATE_STATE'
21:07:18, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / 'list' object has no attribute 'EVALUATE_STATE'
21:07:44, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / 'list' object has no attribute 'EVALUATE_STATE'
21:07:53, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / 'list' object has no attribute 'EVALUATE_STATE'
21:20:12, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / string indices must be integers
21:21:03, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / string indices must be integers
21:21:35, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / string indices must be integers
21:22:25, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / string indices must be integers
21:22:40, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / string indices must be integers
21:23:06, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / string indices must be integers
21:23:26, 30-09-2024 / ERROR in ui.py // PROCESS_UI_STATE / string indices must be integers
17:20:57, 01-10-2024 / ERROR in render.OBJECT_VAO_MANAGER / could not broadcast input array from shape (9,) into shape (8,)
17:23:35, 01-10-2024 / ERROR in Main.py Value initialisation / ('Shader compile failure (0): b"0(24) : error C7565: assignment to varying \'TexCoords\'\\n"', [b'#version 330 core\nlayout(location = 0) in vec3 Position;\nlayout(location = 1) in vec2 TexCoords;\n\nout vec2 fragTexCoords;\n\nvoid main() {\n    vec2 positions[4] = vec2[4](\n        vec2(-1.0,  1.0),  // Top-left\n        vec2(-1.0, -1.0),  // Bottom-left\n        vec2( 1.0, -1.0),  // Bottom-right\n        vec2( 1.0,  1.0)   // Top-right\n    );\n\n    vec2 texCoords[4] = vec2[4](\n        vec2(0.01, 0.99),  // Top-left\n        vec2(0.01, 0.01),  // Bottom-left\n        vec2(0.99, 0.01),  // Bottom-right\n        vec2(0.99, 0.99)   // Top-right\n    );\n\n    // Use gl_VertexID to select the appropriate vertex from the arrays\n    gl_Position = vec4(positions[gl_VertexID], 0.0, 1.0);\n    TexCoords = texCoords[gl_VertexID];\n}'], GL_VERTEX_SHADER)
17:25:08, 01-10-2024 / ERROR in Main.py Value initialisation / ('Shader compile failure (0): b"0(35) : error C7565: assignment to varying \'TexCoords\'\\n"', [b'#version 330 core\nlayout(location = 0) in vec3 Position;\nlayout(location = 1) in vec2 TexCoords;\n\nvoid main() {\n    vec3 positions[8] = vec3[8](\n        // Quad 1 (further back at Z = 0.0)\n        vec3(-1.0,  1.0, 0.0),  // Top-left\n        vec3(-1.0, -1.0, 0.0),  // Bottom-left\n        vec3( 1.0, -1.0, 0.0),  // Bottom-right\n        vec3( 1.0,  1.0, 0.0),  // Top-right\n\n        // Quad 2 (closer at Z = -0.0001)\n        vec3(-1.0,  1.0, -0.0001),  // Top-left\n        vec3(-1.0, -1.0, -0.0001),  // Bottom-left\n        vec3( 1.0, -1.0, -0.0001),  // Bottom-right\n        vec3( 1.0,  1.0, -0.0001)   // Top-right\n    );\n\n    vec2 texCoords[8] = vec2[8](\n        // Texture coordinates for both quads (assumed identical)\n        vec2(0.01, 0.99),  // Top-left\n        vec2(0.01, 0.01),  // Bottom-left\n        vec2(0.99, 0.01),  // Bottom-right\n        vec2(0.99, 0.99),  // Top-right\n        \n        vec2(0.01, 0.99),  // Top-left\n        vec2(0.01, 0.01),  // Bottom-left\n        vec2(0.99, 0.01),  // Bottom-right\n        vec2(0.99, 0.99)   // Top-right\n    );\n\n    // Use gl_VertexID to select the correct vertex from the arrays\n    gl_Position = vec4(positions[gl_VertexID], 1.0);\n    TexCoords = texCoords[gl_VertexID];\n}'], GL_VERTEX_SHADER)
18:45:01, 01-10-2024 / ERROR in Main.py Value initialisation / BUFFERS_INIT() missing 1 required positional argument: 'TEXTURES'
18:46:21, 01-10-2024 / ERROR in Main.py Value initialisation / BUFFERS_INIT() missing 1 required positional argument: 'TEXTURES'
18:46:59, 01-10-2024 / ERROR in Main.py Value initialisation / BUFFERS_INIT() missing 1 required positional argument: 'TEXTURES'
18:47:14, 01-10-2024 / ERROR in Main.py Value initialisation / ('Shader compile failure (0): b\'0(88) : error C1503: undefined variable "SHEETS"\\n\'', [b'#version 330 core\n\nin vec2 fragTexCoords;\nin vec3 fragNormal;\nin vec3 fragPos;\nin int fragSheetID;\n\nout vec4 fragColour;\n\nuniform vec3 CAMERA_POSITION;\nuniform vec3 CAMERA_LOOK_AT;\nuniform vec4 VOID_COLOUR;\nuniform float VIEW_MAX_DIST;\nuniform bool HEADLAMP_ENABLED;\nuniform bool NORMAL_DEBUG;\nuniform bool WIREFRAME_DEBUG;\n\nlayout(std140) uniform SHEETS {\n    uint textureIDs[32];\n};\n\n\n//Mirrors the python equivalent class, bar a few unneccessary attributes.\nstruct LIGHT {\n\tvec3 POSITION;\n\tvec3 LOOK_AT;\n\tvec3 COLOUR;\n\tfloat INTENSITY;\n\tfloat FOV;\n\tfloat MAX_DIST;\n\tmat4 LIGHT_SPACE_MATRIX;\n\tsampler2D SHADOW_MAP;\n\tbool ENABLED;\n};\n\n//Maximum of 64 lights in a scene.\nuniform int LIGHT_COUNT;\nuniform LIGHT LIGHTS[64];\n\n\nfloat FIND_SHADOW(LIGHT LIGHT, vec3 LIGHT_DIRECTION, vec3 NORMAL, vec4 FRAGMENT_POSITION_LIGHT_SPACE, vec3 fragPos) {\n\t//Finds whether or not a fragPos should be in shadow or not, utilising the shadow map, and PCF.\n\n\tvec3 PROJECTED_COORDINATES = FRAGMENT_POSITION_LIGHT_SPACE.xyz / FRAGMENT_POSITION_LIGHT_SPACE.w;\n\tPROJECTED_COORDINATES = (PROJECTED_COORDINATES * 0.5) + 0.5; //Convert projected coordinates to [0.0 - 1.0] range to use as UV\n\n\t//Initialise values such as the mapping bias and whatnot.\n\tfloat SHADOW = 0.0;\n\tvec2 TEXEL_SIZE = 1.5 / textureSize(LIGHT.SHADOW_MAP, 0);\n\tfloat ACTUAL_DEPTH = length(LIGHT.POSITION - fragPos);\n\tif (ACTUAL_DEPTH > LIGHT.MAX_DIST) {\n\t\treturn 1.0;\n\t}\n\tfloat CURRENT_DEPTH = clamp(ACTUAL_DEPTH, LIGHT.MAX_DIST/100, LIGHT.MAX_DIST)/LIGHT.MAX_DIST; //0.0 is the light\'s position, 1.0 at the light\'s maximum distance. Linear.\n\tfloat MAPPING_BIAS = (-1.25e-2 * max(1.0 - dot(NORMAL, LIGHT_DIRECTION), 0.01)) - (2.5e-3 * dot(NORMAL, LIGHT_DIRECTION));\n\n\n\n\tint KERNEL_SIZE = 5; //5 appears to be a good value for this, not too extreme but also not too low.\n\t//Iterate over a square with KERNEL_SIZE "radius" to calculate PCF values.\n\tfor (int X = -KERNEL_SIZE; X <= KERNEL_SIZE; ++X) {\n\t\tfor (int Y = -KERNEL_SIZE; Y <= KERNEL_SIZE; ++Y) {\n\t\t\tfloat SHADOW_MAP_DEPTH = texture(LIGHT.SHADOW_MAP, PROJECTED_COORDINATES.xy + vec2(X, Y) * TEXEL_SIZE).r;\n\t\t\tSHADOW += ((CURRENT_DEPTH + MAPPING_BIAS) > SHADOW_MAP_DEPTH) ? 1.0 : 0.0;\n\t\t}\n\t}\n\n\t//Divide by the KERNEL_SIZE\'s created sample area, so that the value returned is in the [0.0 - 1.0] range again.\n\tSHADOW /= float((KERNEL_SIZE * 2 + 1) * (KERNEL_SIZE * 2 + 1));\n\treturn SHADOW;\n}\n\n\nvoid main() {\n\tif (WIREFRAME_DEBUG) {\n\t\tfragColour = vec4(1.0, 1.0, 1.0, 1.0);\n\t\treturn;\n\t}\n\n\t//Actual fragment depth.\n\tfloat FRAG_DEPTH = length(CAMERA_POSITION - fragPos);\n\tif (FRAG_DEPTH >= VIEW_MAX_DIST) {\n\t\tfragColour = VOID_COLOUR;\n\t\treturn;\n\t}\n\n\t//Initialise colours (texture and default final)\n\tvec4 TEXTURE_COLOUR = texture(SHEETS[fragSheetID], fragTexCoords);\n\tvec3 FINAL_COLOUR = vec3(0.05);\n\t\n\tif (fragNormal == vec3(0.0)) {\n\t\tfragColour = vec4(1.0, 1.0, 0.0, 1.0);\n\t\treturn;\n\t}\n\n\t//Assorted other fragment data.\n\tvec3 NORMAL = (gl_FrontFacing) ? normalize(fragNormal) : normalize(fragNormal) * -1;\n\tfloat DISTANCE_FADE = 1.0 - (FRAG_DEPTH / VIEW_MAX_DIST);\n\n\n\t//Iterate through each light and check if the fragment is within the light\'s FOV, then calculate brightness and colour impact of said light.\n\tfor (int I = 0; I < LIGHT_COUNT; I++) {\n\t\tif (!LIGHTS[I].ENABLED) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tfloat FRAG_LIGHT_DISTANCE = length(LIGHTS[I].POSITION - fragPos);\n\t\tvec3 LIGHT_DIRECTION = normalize(LIGHTS[I].LOOK_AT - fragPos); // Direction to the light\n\t\tvec3 LIGHT_FORWARD = normalize(LIGHTS[I].POSITION - LIGHTS[I].LOOK_AT); // Light\'s forward direction\n\n\t\t//Calculate the angle between the light direction and the light\'s forward direction\n\t\tfloat FOV_COS = dot(LIGHT_DIRECTION, LIGHT_FORWARD); //Dot product of normalized vectors\n\t\tif (degrees(acos(FOV_COS)) > (LIGHTS[I].FOV * 0.5)) {\n\t\t\t//If it\'s out of the light\'s FOV - do not account for this light\'s influence.\n\t\t\tcontinue;\n\t\t}\n\n\t\t//Calculate the angle between the light\'s directional vector and the view\'s surface normal\n\t\tfloat NORMAL_LIGHT_ANGLE = clamp(dot(NORMAL, LIGHT_DIRECTION), 0.0, 1.0);\n\t\t//Prevent excessive FOV values from messing with the rest of the light calculations (negative values, 0 values)\n\t\tif (NORMAL_LIGHT_ANGLE <= 0.01) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t//Calculate the fragPos in the light\'s space\n\t\tvec4 FRAGMENT_POSITION_LIGHT_SPACE = LIGHTS[I].LIGHT_SPACE_MATRIX * vec4(fragPos, 1.0);\n\n\t\t//Brightness component calculations.\n\t\tfloat ATTENUATION = max(0.0, 1.0 - (FRAG_LIGHT_DISTANCE / LIGHTS[I].MAX_DIST)); //"Distance fade from light".\n\t\tfloat DIFFUSE =  2.0 * FOV_COS * FOV_COS - 1.0; //Dimmer as you go further from the "centre" of the light\'s direction.\n\t\tfloat SHADOW = FIND_SHADOW(LIGHTS[I], LIGHT_DIRECTION, NORMAL, FRAGMENT_POSITION_LIGHT_SPACE, fragPos); //Fragment shadow or not.\n\t\tfloat BRIGHTNESS = clamp(ATTENUATION * LIGHTS[I].INTENSITY * DIFFUSE * (1.0 - SHADOW), 0.05, 1.0) * abs(NORMAL_LIGHT_ANGLE); //Combine all the rest into one.\n\n\t\t//Add this light\'s influence to the final colour.\n\t\tFINAL_COLOUR += vec3(TEXTURE_COLOUR.rgb * BRIGHTNESS);\n\t}\n\n\n\n\tif (HEADLAMP_ENABLED) {\n\t\t//If the player\'s headlamp is turned on, cast a light from the camera with fixed FOV/max dist, and no shadows\n\t\t//(Any shadows would simply be hidden from the player\'s view anyhow, and this saves performance.)\n\t\tvec4 HEADLAMP_COLOUR = vec4(1.0, 1.0, 1.0, 1.0); //R, G, B, Intensity.\n\t\tvec3 HEADLAMP_OFFSET = vec3(0.0, 0.0, 0.0);\n\t\tfloat HEADLAMP_MAX_DIST = 10.0;\n\t\tfloat HEADLAMP_FOV = 45.0;\n\n\t\tvec3 HEADLAMP_POSITION = CAMERA_POSITION + HEADLAMP_OFFSET; //Allows for an offset, if needed (Unlikely, but supported.)\n\n\n\n\t\tfloat FRAG_CAMERA_DISTANCE = length(HEADLAMP_POSITION - fragPos);\n\t\tvec3 FRAG_HEADLAMP_DIRECTION = normalize(HEADLAMP_POSITION - fragPos); // Direction to the light\n\t\tvec3 HEADLAMP_FORWARD = normalize(HEADLAMP_POSITION - CAMERA_LOOK_AT); // Light\'s forward direction\n\n\t\t//Calculate the angle between the light direction and the light\'s forward direction\n\t\tfloat FOV_COS = dot(FRAG_HEADLAMP_DIRECTION, HEADLAMP_FORWARD); //Dot product of normalized vectors\n\n\t\tif (degrees(acos(FOV_COS)) <= (HEADLAMP_FOV * 0.5)) {\n\t\t\t//Calculate the angle between the light\'s directional vector and the view\'s surface normal\n\t\t\tfloat NORMAL_LIGHT_ANGLE = clamp(dot(NORMAL, FRAG_HEADLAMP_DIRECTION), 0.0, 1.0);\n\n\t\t\t//Prevent excessive FOV values from messing with the rest of the light calculations (negative values, 0 values)\n\t\t\tif (NORMAL_LIGHT_ANGLE > 0.01) {\n\t\t\t\t//Brightness component calculations.\n\t\t\t\tfloat ATTENUATION = max(0.0, 1.0 - (FRAG_CAMERA_DISTANCE / HEADLAMP_MAX_DIST)); //"Distance fade from light".\n\t\t\t\tfloat DIFFUSE =  2.0 * FOV_COS * FOV_COS - 1.0; //Dimmer as you go further from the "centre" of the light\'s direction.\n\t\t\t\tfloat BRIGHTNESS = clamp(ATTENUATION * HEADLAMP_COLOUR.w * DIFFUSE, 0.05, 1.0) * abs(NORMAL_LIGHT_ANGLE); //Combine all the rest into one.\n\n\t\t\t\t//Add this light\'s influence to the final colour.\n\t\t\t\tFINAL_COLOUR += vec3(TEXTURE_COLOUR.rgb * BRIGHTNESS);\n\t\t\t}\n\t\t}\n\n\n\t}\n\n\n\n\tif (!NORMAL_DEBUG) {\n\t\t//Display final colour\n\t\tfragColour = vec4(FINAL_COLOUR * DISTANCE_FADE, TEXTURE_COLOUR.a);\n\t} else {\n\t\t//Display the surface normals as RGB, where (0, 0, 0) would be (0.5, 0.5, 0.5).\n\t\tfragColour = vec4((NORMAL.xyz * 0.5) + vec3(0.5), 1.0);\n\t}\n}'], GL_FRAGMENT_SHADER)
18:47:41, 01-10-2024 / ERROR in Main.py Value initialisation / ('Shader compile failure (0): b\'0(19) : error C1002: the name "SHEETS" is already defined at 0(20)\\n0(88) : error C1503: undefined variable "SHEETS"\\n\'', [b'#version 330 core\n\nin vec2 fragTexCoords;\nin vec3 fragNormal;\nin vec3 fragPos;\nin int fragSheetID;\n\nout vec4 fragColour;\n\nuniform vec3 CAMERA_POSITION;\nuniform vec3 CAMERA_LOOK_AT;\nuniform vec4 VOID_COLOUR;\nuniform float VIEW_MAX_DIST;\nuniform bool HEADLAMP_ENABLED;\nuniform bool NORMAL_DEBUG;\nuniform bool WIREFRAME_DEBUG;\n\nlayout(std140) uniform SHEETS {\n    uint SHEETS[32];\n};\n\n\n//Mirrors the python equivalent class, bar a few unneccessary attributes.\nstruct LIGHT {\n\tvec3 POSITION;\n\tvec3 LOOK_AT;\n\tvec3 COLOUR;\n\tfloat INTENSITY;\n\tfloat FOV;\n\tfloat MAX_DIST;\n\tmat4 LIGHT_SPACE_MATRIX;\n\tsampler2D SHADOW_MAP;\n\tbool ENABLED;\n};\n\n//Maximum of 64 lights in a scene.\nuniform int LIGHT_COUNT;\nuniform LIGHT LIGHTS[64];\n\n\nfloat FIND_SHADOW(LIGHT LIGHT, vec3 LIGHT_DIRECTION, vec3 NORMAL, vec4 FRAGMENT_POSITION_LIGHT_SPACE, vec3 fragPos) {\n\t//Finds whether or not a fragPos should be in shadow or not, utilising the shadow map, and PCF.\n\n\tvec3 PROJECTED_COORDINATES = FRAGMENT_POSITION_LIGHT_SPACE.xyz / FRAGMENT_POSITION_LIGHT_SPACE.w;\n\tPROJECTED_COORDINATES = (PROJECTED_COORDINATES * 0.5) + 0.5; //Convert projected coordinates to [0.0 - 1.0] range to use as UV\n\n\t//Initialise values such as the mapping bias and whatnot.\n\tfloat SHADOW = 0.0;\n\tvec2 TEXEL_SIZE = 1.5 / textureSize(LIGHT.SHADOW_MAP, 0);\n\tfloat ACTUAL_DEPTH = length(LIGHT.POSITION - fragPos);\n\tif (ACTUAL_DEPTH > LIGHT.MAX_DIST) {\n\t\treturn 1.0;\n\t}\n\tfloat CURRENT_DEPTH = clamp(ACTUAL_DEPTH, LIGHT.MAX_DIST/100, LIGHT.MAX_DIST)/LIGHT.MAX_DIST; //0.0 is the light\'s position, 1.0 at the light\'s maximum distance. Linear.\n\tfloat MAPPING_BIAS = (-1.25e-2 * max(1.0 - dot(NORMAL, LIGHT_DIRECTION), 0.01)) - (2.5e-3 * dot(NORMAL, LIGHT_DIRECTION));\n\n\n\n\tint KERNEL_SIZE = 5; //5 appears to be a good value for this, not too extreme but also not too low.\n\t//Iterate over a square with KERNEL_SIZE "radius" to calculate PCF values.\n\tfor (int X = -KERNEL_SIZE; X <= KERNEL_SIZE; ++X) {\n\t\tfor (int Y = -KERNEL_SIZE; Y <= KERNEL_SIZE; ++Y) {\n\t\t\tfloat SHADOW_MAP_DEPTH = texture(LIGHT.SHADOW_MAP, PROJECTED_COORDINATES.xy + vec2(X, Y) * TEXEL_SIZE).r;\n\t\t\tSHADOW += ((CURRENT_DEPTH + MAPPING_BIAS) > SHADOW_MAP_DEPTH) ? 1.0 : 0.0;\n\t\t}\n\t}\n\n\t//Divide by the KERNEL_SIZE\'s created sample area, so that the value returned is in the [0.0 - 1.0] range again.\n\tSHADOW /= float((KERNEL_SIZE * 2 + 1) * (KERNEL_SIZE * 2 + 1));\n\treturn SHADOW;\n}\n\n\nvoid main() {\n\tif (WIREFRAME_DEBUG) {\n\t\tfragColour = vec4(1.0, 1.0, 1.0, 1.0);\n\t\treturn;\n\t}\n\n\t//Actual fragment depth.\n\tfloat FRAG_DEPTH = length(CAMERA_POSITION - fragPos);\n\tif (FRAG_DEPTH >= VIEW_MAX_DIST) {\n\t\tfragColour = VOID_COLOUR;\n\t\treturn;\n\t}\n\n\t//Initialise colours (texture and default final)\n\tvec4 TEXTURE_COLOUR = texture(SHEETS[fragSheetID], fragTexCoords);\n\tvec3 FINAL_COLOUR = vec3(0.05);\n\t\n\tif (fragNormal == vec3(0.0)) {\n\t\tfragColour = vec4(1.0, 1.0, 0.0, 1.0);\n\t\treturn;\n\t}\n\n\t//Assorted other fragment data.\n\tvec3 NORMAL = (gl_FrontFacing) ? normalize(fragNormal) : normalize(fragNormal) * -1;\n\tfloat DISTANCE_FADE = 1.0 - (FRAG_DEPTH / VIEW_MAX_DIST);\n\n\n\t//Iterate through each light and check if the fragment is within the light\'s FOV, then calculate brightness and colour impact of said light.\n\tfor (int I = 0; I < LIGHT_COUNT; I++) {\n\t\tif (!LIGHTS[I].ENABLED) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tfloat FRAG_LIGHT_DISTANCE = length(LIGHTS[I].POSITION - fragPos);\n\t\tvec3 LIGHT_DIRECTION = normalize(LIGHTS[I].LOOK_AT - fragPos); // Direction to the light\n\t\tvec3 LIGHT_FORWARD = normalize(LIGHTS[I].POSITION - LIGHTS[I].LOOK_AT); // Light\'s forward direction\n\n\t\t//Calculate the angle between the light direction and the light\'s forward direction\n\t\tfloat FOV_COS = dot(LIGHT_DIRECTION, LIGHT_FORWARD); //Dot product of normalized vectors\n\t\tif (degrees(acos(FOV_COS)) > (LIGHTS[I].FOV * 0.5)) {\n\t\t\t//If it\'s out of the light\'s FOV - do not account for this light\'s influence.\n\t\t\tcontinue;\n\t\t}\n\n\t\t//Calculate the angle between the light\'s directional vector and the view\'s surface normal\n\t\tfloat NORMAL_LIGHT_ANGLE = clamp(dot(NORMAL, LIGHT_DIRECTION), 0.0, 1.0);\n\t\t//Prevent excessive FOV values from messing with the rest of the light calculations (negative values, 0 values)\n\t\tif (NORMAL_LIGHT_ANGLE <= 0.01) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t//Calculate the fragPos in the light\'s space\n\t\tvec4 FRAGMENT_POSITION_LIGHT_SPACE = LIGHTS[I].LIGHT_SPACE_MATRIX * vec4(fragPos, 1.0);\n\n\t\t//Brightness component calculations.\n\t\tfloat ATTENUATION = max(0.0, 1.0 - (FRAG_LIGHT_DISTANCE / LIGHTS[I].MAX_DIST)); //"Distance fade from light".\n\t\tfloat DIFFUSE =  2.0 * FOV_COS * FOV_COS - 1.0; //Dimmer as you go further from the "centre" of the light\'s direction.\n\t\tfloat SHADOW = FIND_SHADOW(LIGHTS[I], LIGHT_DIRECTION, NORMAL, FRAGMENT_POSITION_LIGHT_SPACE, fragPos); //Fragment shadow or not.\n\t\tfloat BRIGHTNESS = clamp(ATTENUATION * LIGHTS[I].INTENSITY * DIFFUSE * (1.0 - SHADOW), 0.05, 1.0) * abs(NORMAL_LIGHT_ANGLE); //Combine all the rest into one.\n\n\t\t//Add this light\'s influence to the final colour.\n\t\tFINAL_COLOUR += vec3(TEXTURE_COLOUR.rgb * BRIGHTNESS);\n\t}\n\n\n\n\tif (HEADLAMP_ENABLED) {\n\t\t//If the player\'s headlamp is turned on, cast a light from the camera with fixed FOV/max dist, and no shadows\n\t\t//(Any shadows would simply be hidden from the player\'s view anyhow, and this saves performance.)\n\t\tvec4 HEADLAMP_COLOUR = vec4(1.0, 1.0, 1.0, 1.0); //R, G, B, Intensity.\n\t\tvec3 HEADLAMP_OFFSET = vec3(0.0, 0.0, 0.0);\n\t\tfloat HEADLAMP_MAX_DIST = 10.0;\n\t\tfloat HEADLAMP_FOV = 45.0;\n\n\t\tvec3 HEADLAMP_POSITION = CAMERA_POSITION + HEADLAMP_OFFSET; //Allows for an offset, if needed (Unlikely, but supported.)\n\n\n\n\t\tfloat FRAG_CAMERA_DISTANCE = length(HEADLAMP_POSITION - fragPos);\n\t\tvec3 FRAG_HEADLAMP_DIRECTION = normalize(HEADLAMP_POSITION - fragPos); // Direction to the light\n\t\tvec3 HEADLAMP_FORWARD = normalize(HEADLAMP_POSITION - CAMERA_LOOK_AT); // Light\'s forward direction\n\n\t\t//Calculate the angle between the light direction and the light\'s forward direction\n\t\tfloat FOV_COS = dot(FRAG_HEADLAMP_DIRECTION, HEADLAMP_FORWARD); //Dot product of normalized vectors\n\n\t\tif (degrees(acos(FOV_COS)) <= (HEADLAMP_FOV * 0.5)) {\n\t\t\t//Calculate the angle between the light\'s directional vector and the view\'s surface normal\n\t\t\tfloat NORMAL_LIGHT_ANGLE = clamp(dot(NORMAL, FRAG_HEADLAMP_DIRECTION), 0.0, 1.0);\n\n\t\t\t//Prevent excessive FOV values from messing with the rest of the light calculations (negative values, 0 values)\n\t\t\tif (NORMAL_LIGHT_ANGLE > 0.01) {\n\t\t\t\t//Brightness component calculations.\n\t\t\t\tfloat ATTENUATION = max(0.0, 1.0 - (FRAG_CAMERA_DISTANCE / HEADLAMP_MAX_DIST)); //"Distance fade from light".\n\t\t\t\tfloat DIFFUSE =  2.0 * FOV_COS * FOV_COS - 1.0; //Dimmer as you go further from the "centre" of the light\'s direction.\n\t\t\t\tfloat BRIGHTNESS = clamp(ATTENUATION * HEADLAMP_COLOUR.w * DIFFUSE, 0.05, 1.0) * abs(NORMAL_LIGHT_ANGLE); //Combine all the rest into one.\n\n\t\t\t\t//Add this light\'s influence to the final colour.\n\t\t\t\tFINAL_COLOUR += vec3(TEXTURE_COLOUR.rgb * BRIGHTNESS);\n\t\t\t}\n\t\t}\n\n\n\t}\n\n\n\n\tif (!NORMAL_DEBUG) {\n\t\t//Display final colour\n\t\tfragColour = vec4(FINAL_COLOUR * DISTANCE_FADE, TEXTURE_COLOUR.a);\n\t} else {\n\t\t//Display the surface normals as RGB, where (0, 0, 0) would be (0.5, 0.5, 0.5).\n\t\tfragColour = vec4((NORMAL.xyz * 0.5) + vec3(0.5), 1.0);\n\t}\n}'], GL_FRAGMENT_SHADER)
18:48:07, 01-10-2024 / ERROR in Main.py Value initialisation / ('Shader compile failure (0): b\'0(88) : error C1115: unable to find compatible overloaded function "texture(uint, vec2)"\\n\'', [b'#version 330 core\n\nin vec2 fragTexCoords;\nin vec3 fragNormal;\nin vec3 fragPos;\nin int fragSheetID;\n\nout vec4 fragColour;\n\nuniform vec3 CAMERA_POSITION;\nuniform vec3 CAMERA_LOOK_AT;\nuniform vec4 VOID_COLOUR;\nuniform float VIEW_MAX_DIST;\nuniform bool HEADLAMP_ENABLED;\nuniform bool NORMAL_DEBUG;\nuniform bool WIREFRAME_DEBUG;\n\nlayout(std140) uniform TEXTURE_IDs {\n    uint SHEETS[32];\n};\n\n\n//Mirrors the python equivalent class, bar a few unneccessary attributes.\nstruct LIGHT {\n\tvec3 POSITION;\n\tvec3 LOOK_AT;\n\tvec3 COLOUR;\n\tfloat INTENSITY;\n\tfloat FOV;\n\tfloat MAX_DIST;\n\tmat4 LIGHT_SPACE_MATRIX;\n\tsampler2D SHADOW_MAP;\n\tbool ENABLED;\n};\n\n//Maximum of 64 lights in a scene.\nuniform int LIGHT_COUNT;\nuniform LIGHT LIGHTS[64];\n\n\nfloat FIND_SHADOW(LIGHT LIGHT, vec3 LIGHT_DIRECTION, vec3 NORMAL, vec4 FRAGMENT_POSITION_LIGHT_SPACE, vec3 fragPos) {\n\t//Finds whether or not a fragPos should be in shadow or not, utilising the shadow map, and PCF.\n\n\tvec3 PROJECTED_COORDINATES = FRAGMENT_POSITION_LIGHT_SPACE.xyz / FRAGMENT_POSITION_LIGHT_SPACE.w;\n\tPROJECTED_COORDINATES = (PROJECTED_COORDINATES * 0.5) + 0.5; //Convert projected coordinates to [0.0 - 1.0] range to use as UV\n\n\t//Initialise values such as the mapping bias and whatnot.\n\tfloat SHADOW = 0.0;\n\tvec2 TEXEL_SIZE = 1.5 / textureSize(LIGHT.SHADOW_MAP, 0);\n\tfloat ACTUAL_DEPTH = length(LIGHT.POSITION - fragPos);\n\tif (ACTUAL_DEPTH > LIGHT.MAX_DIST) {\n\t\treturn 1.0;\n\t}\n\tfloat CURRENT_DEPTH = clamp(ACTUAL_DEPTH, LIGHT.MAX_DIST/100, LIGHT.MAX_DIST)/LIGHT.MAX_DIST; //0.0 is the light\'s position, 1.0 at the light\'s maximum distance. Linear.\n\tfloat MAPPING_BIAS = (-1.25e-2 * max(1.0 - dot(NORMAL, LIGHT_DIRECTION), 0.01)) - (2.5e-3 * dot(NORMAL, LIGHT_DIRECTION));\n\n\n\n\tint KERNEL_SIZE = 5; //5 appears to be a good value for this, not too extreme but also not too low.\n\t//Iterate over a square with KERNEL_SIZE "radius" to calculate PCF values.\n\tfor (int X = -KERNEL_SIZE; X <= KERNEL_SIZE; ++X) {\n\t\tfor (int Y = -KERNEL_SIZE; Y <= KERNEL_SIZE; ++Y) {\n\t\t\tfloat SHADOW_MAP_DEPTH = texture(LIGHT.SHADOW_MAP, PROJECTED_COORDINATES.xy + vec2(X, Y) * TEXEL_SIZE).r;\n\t\t\tSHADOW += ((CURRENT_DEPTH + MAPPING_BIAS) > SHADOW_MAP_DEPTH) ? 1.0 : 0.0;\n\t\t}\n\t}\n\n\t//Divide by the KERNEL_SIZE\'s created sample area, so that the value returned is in the [0.0 - 1.0] range again.\n\tSHADOW /= float((KERNEL_SIZE * 2 + 1) * (KERNEL_SIZE * 2 + 1));\n\treturn SHADOW;\n}\n\n\nvoid main() {\n\tif (WIREFRAME_DEBUG) {\n\t\tfragColour = vec4(1.0, 1.0, 1.0, 1.0);\n\t\treturn;\n\t}\n\n\t//Actual fragment depth.\n\tfloat FRAG_DEPTH = length(CAMERA_POSITION - fragPos);\n\tif (FRAG_DEPTH >= VIEW_MAX_DIST) {\n\t\tfragColour = VOID_COLOUR;\n\t\treturn;\n\t}\n\n\t//Initialise colours (texture and default final)\n\tvec4 TEXTURE_COLOUR = texture(SHEETS[fragSheetID], fragTexCoords);\n\tvec3 FINAL_COLOUR = vec3(0.05);\n\t\n\tif (fragNormal == vec3(0.0)) {\n\t\tfragColour = vec4(1.0, 1.0, 0.0, 1.0);\n\t\treturn;\n\t}\n\n\t//Assorted other fragment data.\n\tvec3 NORMAL = (gl_FrontFacing) ? normalize(fragNormal) : normalize(fragNormal) * -1;\n\tfloat DISTANCE_FADE = 1.0 - (FRAG_DEPTH / VIEW_MAX_DIST);\n\n\n\t//Iterate through each light and check if the fragment is within the light\'s FOV, then calculate brightness and colour impact of said light.\n\tfor (int I = 0; I < LIGHT_COUNT; I++) {\n\t\tif (!LIGHTS[I].ENABLED) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tfloat FRAG_LIGHT_DISTANCE = length(LIGHTS[I].POSITION - fragPos);\n\t\tvec3 LIGHT_DIRECTION = normalize(LIGHTS[I].LOOK_AT - fragPos); // Direction to the light\n\t\tvec3 LIGHT_FORWARD = normalize(LIGHTS[I].POSITION - LIGHTS[I].LOOK_AT); // Light\'s forward direction\n\n\t\t//Calculate the angle between the light direction and the light\'s forward direction\n\t\tfloat FOV_COS = dot(LIGHT_DIRECTION, LIGHT_FORWARD); //Dot product of normalized vectors\n\t\tif (degrees(acos(FOV_COS)) > (LIGHTS[I].FOV * 0.5)) {\n\t\t\t//If it\'s out of the light\'s FOV - do not account for this light\'s influence.\n\t\t\tcontinue;\n\t\t}\n\n\t\t//Calculate the angle between the light\'s directional vector and the view\'s surface normal\n\t\tfloat NORMAL_LIGHT_ANGLE = clamp(dot(NORMAL, LIGHT_DIRECTION), 0.0, 1.0);\n\t\t//Prevent excessive FOV values from messing with the rest of the light calculations (negative values, 0 values)\n\t\tif (NORMAL_LIGHT_ANGLE <= 0.01) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t//Calculate the fragPos in the light\'s space\n\t\tvec4 FRAGMENT_POSITION_LIGHT_SPACE = LIGHTS[I].LIGHT_SPACE_MATRIX * vec4(fragPos, 1.0);\n\n\t\t//Brightness component calculations.\n\t\tfloat ATTENUATION = max(0.0, 1.0 - (FRAG_LIGHT_DISTANCE / LIGHTS[I].MAX_DIST)); //"Distance fade from light".\n\t\tfloat DIFFUSE =  2.0 * FOV_COS * FOV_COS - 1.0; //Dimmer as you go further from the "centre" of the light\'s direction.\n\t\tfloat SHADOW = FIND_SHADOW(LIGHTS[I], LIGHT_DIRECTION, NORMAL, FRAGMENT_POSITION_LIGHT_SPACE, fragPos); //Fragment shadow or not.\n\t\tfloat BRIGHTNESS = clamp(ATTENUATION * LIGHTS[I].INTENSITY * DIFFUSE * (1.0 - SHADOW), 0.05, 1.0) * abs(NORMAL_LIGHT_ANGLE); //Combine all the rest into one.\n\n\t\t//Add this light\'s influence to the final colour.\n\t\tFINAL_COLOUR += vec3(TEXTURE_COLOUR.rgb * BRIGHTNESS);\n\t}\n\n\n\n\tif (HEADLAMP_ENABLED) {\n\t\t//If the player\'s headlamp is turned on, cast a light from the camera with fixed FOV/max dist, and no shadows\n\t\t//(Any shadows would simply be hidden from the player\'s view anyhow, and this saves performance.)\n\t\tvec4 HEADLAMP_COLOUR = vec4(1.0, 1.0, 1.0, 1.0); //R, G, B, Intensity.\n\t\tvec3 HEADLAMP_OFFSET = vec3(0.0, 0.0, 0.0);\n\t\tfloat HEADLAMP_MAX_DIST = 10.0;\n\t\tfloat HEADLAMP_FOV = 45.0;\n\n\t\tvec3 HEADLAMP_POSITION = CAMERA_POSITION + HEADLAMP_OFFSET; //Allows for an offset, if needed (Unlikely, but supported.)\n\n\n\n\t\tfloat FRAG_CAMERA_DISTANCE = length(HEADLAMP_POSITION - fragPos);\n\t\tvec3 FRAG_HEADLAMP_DIRECTION = normalize(HEADLAMP_POSITION - fragPos); // Direction to the light\n\t\tvec3 HEADLAMP_FORWARD = normalize(HEADLAMP_POSITION - CAMERA_LOOK_AT); // Light\'s forward direction\n\n\t\t//Calculate the angle between the light direction and the light\'s forward direction\n\t\tfloat FOV_COS = dot(FRAG_HEADLAMP_DIRECTION, HEADLAMP_FORWARD); //Dot product of normalized vectors\n\n\t\tif (degrees(acos(FOV_COS)) <= (HEADLAMP_FOV * 0.5)) {\n\t\t\t//Calculate the angle between the light\'s directional vector and the view\'s surface normal\n\t\t\tfloat NORMAL_LIGHT_ANGLE = clamp(dot(NORMAL, FRAG_HEADLAMP_DIRECTION), 0.0, 1.0);\n\n\t\t\t//Prevent excessive FOV values from messing with the rest of the light calculations (negative values, 0 values)\n\t\t\tif (NORMAL_LIGHT_ANGLE > 0.01) {\n\t\t\t\t//Brightness component calculations.\n\t\t\t\tfloat ATTENUATION = max(0.0, 1.0 - (FRAG_CAMERA_DISTANCE / HEADLAMP_MAX_DIST)); //"Distance fade from light".\n\t\t\t\tfloat DIFFUSE =  2.0 * FOV_COS * FOV_COS - 1.0; //Dimmer as you go further from the "centre" of the light\'s direction.\n\t\t\t\tfloat BRIGHTNESS = clamp(ATTENUATION * HEADLAMP_COLOUR.w * DIFFUSE, 0.05, 1.0) * abs(NORMAL_LIGHT_ANGLE); //Combine all the rest into one.\n\n\t\t\t\t//Add this light\'s influence to the final colour.\n\t\t\t\tFINAL_COLOUR += vec3(TEXTURE_COLOUR.rgb * BRIGHTNESS);\n\t\t\t}\n\t\t}\n\n\n\t}\n\n\n\n\tif (!NORMAL_DEBUG) {\n\t\t//Display final colour\n\t\tfragColour = vec4(FINAL_COLOUR * DISTANCE_FADE, TEXTURE_COLOUR.a);\n\t} else {\n\t\t//Display the surface normals as RGB, where (0, 0, 0) would be (0.5, 0.5, 0.5).\n\t\tfragColour = vec4((NORMAL.xyz * 0.5) + vec3(0.5), 1.0);\n\t}\n}'], GL_FRAGMENT_SHADER)
18:48:29, 01-10-2024 / ERROR in Main.py Value initialisation / ("Shader compile failure (0): b'0(19) : error C7554: OpenGL requires sampler variables to be explicitly declared as uniform\\n'", [b'#version 330 core\n\nin vec2 fragTexCoords;\nin vec3 fragNormal;\nin vec3 fragPos;\nin int fragSheetID;\n\nout vec4 fragColour;\n\nuniform vec3 CAMERA_POSITION;\nuniform vec3 CAMERA_LOOK_AT;\nuniform vec4 VOID_COLOUR;\nuniform float VIEW_MAX_DIST;\nuniform bool HEADLAMP_ENABLED;\nuniform bool NORMAL_DEBUG;\nuniform bool WIREFRAME_DEBUG;\n\nlayout(std140) uniform TEXTURE_IDs {\n    sampler2D SHEETS[32];\n};\n\n\n//Mirrors the python equivalent class, bar a few unneccessary attributes.\nstruct LIGHT {\n\tvec3 POSITION;\n\tvec3 LOOK_AT;\n\tvec3 COLOUR;\n\tfloat INTENSITY;\n\tfloat FOV;\n\tfloat MAX_DIST;\n\tmat4 LIGHT_SPACE_MATRIX;\n\tsampler2D SHADOW_MAP;\n\tbool ENABLED;\n};\n\n//Maximum of 64 lights in a scene.\nuniform int LIGHT_COUNT;\nuniform LIGHT LIGHTS[64];\n\n\nfloat FIND_SHADOW(LIGHT LIGHT, vec3 LIGHT_DIRECTION, vec3 NORMAL, vec4 FRAGMENT_POSITION_LIGHT_SPACE, vec3 fragPos) {\n\t//Finds whether or not a fragPos should be in shadow or not, utilising the shadow map, and PCF.\n\n\tvec3 PROJECTED_COORDINATES = FRAGMENT_POSITION_LIGHT_SPACE.xyz / FRAGMENT_POSITION_LIGHT_SPACE.w;\n\tPROJECTED_COORDINATES = (PROJECTED_COORDINATES * 0.5) + 0.5; //Convert projected coordinates to [0.0 - 1.0] range to use as UV\n\n\t//Initialise values such as the mapping bias and whatnot.\n\tfloat SHADOW = 0.0;\n\tvec2 TEXEL_SIZE = 1.5 / textureSize(LIGHT.SHADOW_MAP, 0);\n\tfloat ACTUAL_DEPTH = length(LIGHT.POSITION - fragPos);\n\tif (ACTUAL_DEPTH > LIGHT.MAX_DIST) {\n\t\treturn 1.0;\n\t}\n\tfloat CURRENT_DEPTH = clamp(ACTUAL_DEPTH, LIGHT.MAX_DIST/100, LIGHT.MAX_DIST)/LIGHT.MAX_DIST; //0.0 is the light\'s position, 1.0 at the light\'s maximum distance. Linear.\n\tfloat MAPPING_BIAS = (-1.25e-2 * max(1.0 - dot(NORMAL, LIGHT_DIRECTION), 0.01)) - (2.5e-3 * dot(NORMAL, LIGHT_DIRECTION));\n\n\n\n\tint KERNEL_SIZE = 5; //5 appears to be a good value for this, not too extreme but also not too low.\n\t//Iterate over a square with KERNEL_SIZE "radius" to calculate PCF values.\n\tfor (int X = -KERNEL_SIZE; X <= KERNEL_SIZE; ++X) {\n\t\tfor (int Y = -KERNEL_SIZE; Y <= KERNEL_SIZE; ++Y) {\n\t\t\tfloat SHADOW_MAP_DEPTH = texture(LIGHT.SHADOW_MAP, PROJECTED_COORDINATES.xy + vec2(X, Y) * TEXEL_SIZE).r;\n\t\t\tSHADOW += ((CURRENT_DEPTH + MAPPING_BIAS) > SHADOW_MAP_DEPTH) ? 1.0 : 0.0;\n\t\t}\n\t}\n\n\t//Divide by the KERNEL_SIZE\'s created sample area, so that the value returned is in the [0.0 - 1.0] range again.\n\tSHADOW /= float((KERNEL_SIZE * 2 + 1) * (KERNEL_SIZE * 2 + 1));\n\treturn SHADOW;\n}\n\n\nvoid main() {\n\tif (WIREFRAME_DEBUG) {\n\t\tfragColour = vec4(1.0, 1.0, 1.0, 1.0);\n\t\treturn;\n\t}\n\n\t//Actual fragment depth.\n\tfloat FRAG_DEPTH = length(CAMERA_POSITION - fragPos);\n\tif (FRAG_DEPTH >= VIEW_MAX_DIST) {\n\t\tfragColour = VOID_COLOUR;\n\t\treturn;\n\t}\n\n\t//Initialise colours (texture and default final)\n\tvec4 TEXTURE_COLOUR = texture(SHEETS[fragSheetID], fragTexCoords);\n\tvec3 FINAL_COLOUR = vec3(0.05);\n\t\n\tif (fragNormal == vec3(0.0)) {\n\t\tfragColour = vec4(1.0, 1.0, 0.0, 1.0);\n\t\treturn;\n\t}\n\n\t//Assorted other fragment data.\n\tvec3 NORMAL = (gl_FrontFacing) ? normalize(fragNormal) : normalize(fragNormal) * -1;\n\tfloat DISTANCE_FADE = 1.0 - (FRAG_DEPTH / VIEW_MAX_DIST);\n\n\n\t//Iterate through each light and check if the fragment is within the light\'s FOV, then calculate brightness and colour impact of said light.\n\tfor (int I = 0; I < LIGHT_COUNT; I++) {\n\t\tif (!LIGHTS[I].ENABLED) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tfloat FRAG_LIGHT_DISTANCE = length(LIGHTS[I].POSITION - fragPos);\n\t\tvec3 LIGHT_DIRECTION = normalize(LIGHTS[I].LOOK_AT - fragPos); // Direction to the light\n\t\tvec3 LIGHT_FORWARD = normalize(LIGHTS[I].POSITION - LIGHTS[I].LOOK_AT); // Light\'s forward direction\n\n\t\t//Calculate the angle between the light direction and the light\'s forward direction\n\t\tfloat FOV_COS = dot(LIGHT_DIRECTION, LIGHT_FORWARD); //Dot product of normalized vectors\n\t\tif (degrees(acos(FOV_COS)) > (LIGHTS[I].FOV * 0.5)) {\n\t\t\t//If it\'s out of the light\'s FOV - do not account for this light\'s influence.\n\t\t\tcontinue;\n\t\t}\n\n\t\t//Calculate the angle between the light\'s directional vector and the view\'s surface normal\n\t\tfloat NORMAL_LIGHT_ANGLE = clamp(dot(NORMAL, LIGHT_DIRECTION), 0.0, 1.0);\n\t\t//Prevent excessive FOV values from messing with the rest of the light calculations (negative values, 0 values)\n\t\tif (NORMAL_LIGHT_ANGLE <= 0.01) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t//Calculate the fragPos in the light\'s space\n\t\tvec4 FRAGMENT_POSITION_LIGHT_SPACE = LIGHTS[I].LIGHT_SPACE_MATRIX * vec4(fragPos, 1.0);\n\n\t\t//Brightness component calculations.\n\t\tfloat ATTENUATION = max(0.0, 1.0 - (FRAG_LIGHT_DISTANCE / LIGHTS[I].MAX_DIST)); //"Distance fade from light".\n\t\tfloat DIFFUSE =  2.0 * FOV_COS * FOV_COS - 1.0; //Dimmer as you go further from the "centre" of the light\'s direction.\n\t\tfloat SHADOW = FIND_SHADOW(LIGHTS[I], LIGHT_DIRECTION, NORMAL, FRAGMENT_POSITION_LIGHT_SPACE, fragPos); //Fragment shadow or not.\n\t\tfloat BRIGHTNESS = clamp(ATTENUATION * LIGHTS[I].INTENSITY * DIFFUSE * (1.0 - SHADOW), 0.05, 1.0) * abs(NORMAL_LIGHT_ANGLE); //Combine all the rest into one.\n\n\t\t//Add this light\'s influence to the final colour.\n\t\tFINAL_COLOUR += vec3(TEXTURE_COLOUR.rgb * BRIGHTNESS);\n\t}\n\n\n\n\tif (HEADLAMP_ENABLED) {\n\t\t//If the player\'s headlamp is turned on, cast a light from the camera with fixed FOV/max dist, and no shadows\n\t\t//(Any shadows would simply be hidden from the player\'s view anyhow, and this saves performance.)\n\t\tvec4 HEADLAMP_COLOUR = vec4(1.0, 1.0, 1.0, 1.0); //R, G, B, Intensity.\n\t\tvec3 HEADLAMP_OFFSET = vec3(0.0, 0.0, 0.0);\n\t\tfloat HEADLAMP_MAX_DIST = 10.0;\n\t\tfloat HEADLAMP_FOV = 45.0;\n\n\t\tvec3 HEADLAMP_POSITION = CAMERA_POSITION + HEADLAMP_OFFSET; //Allows for an offset, if needed (Unlikely, but supported.)\n\n\n\n\t\tfloat FRAG_CAMERA_DISTANCE = length(HEADLAMP_POSITION - fragPos);\n\t\tvec3 FRAG_HEADLAMP_DIRECTION = normalize(HEADLAMP_POSITION - fragPos); // Direction to the light\n\t\tvec3 HEADLAMP_FORWARD = normalize(HEADLAMP_POSITION - CAMERA_LOOK_AT); // Light\'s forward direction\n\n\t\t//Calculate the angle between the light direction and the light\'s forward direction\n\t\tfloat FOV_COS = dot(FRAG_HEADLAMP_DIRECTION, HEADLAMP_FORWARD); //Dot product of normalized vectors\n\n\t\tif (degrees(acos(FOV_COS)) <= (HEADLAMP_FOV * 0.5)) {\n\t\t\t//Calculate the angle between the light\'s directional vector and the view\'s surface normal\n\t\t\tfloat NORMAL_LIGHT_ANGLE = clamp(dot(NORMAL, FRAG_HEADLAMP_DIRECTION), 0.0, 1.0);\n\n\t\t\t//Prevent excessive FOV values from messing with the rest of the light calculations (negative values, 0 values)\n\t\t\tif (NORMAL_LIGHT_ANGLE > 0.01) {\n\t\t\t\t//Brightness component calculations.\n\t\t\t\tfloat ATTENUATION = max(0.0, 1.0 - (FRAG_CAMERA_DISTANCE / HEADLAMP_MAX_DIST)); //"Distance fade from light".\n\t\t\t\tfloat DIFFUSE =  2.0 * FOV_COS * FOV_COS - 1.0; //Dimmer as you go further from the "centre" of the light\'s direction.\n\t\t\t\tfloat BRIGHTNESS = clamp(ATTENUATION * HEADLAMP_COLOUR.w * DIFFUSE, 0.05, 1.0) * abs(NORMAL_LIGHT_ANGLE); //Combine all the rest into one.\n\n\t\t\t\t//Add this light\'s influence to the final colour.\n\t\t\t\tFINAL_COLOUR += vec3(TEXTURE_COLOUR.rgb * BRIGHTNESS);\n\t\t\t}\n\t\t}\n\n\n\t}\n\n\n\n\tif (!NORMAL_DEBUG) {\n\t\t//Display final colour\n\t\tfragColour = vec4(FINAL_COLOUR * DISTANCE_FADE, TEXTURE_COLOUR.a);\n\t} else {\n\t\t//Display the surface normals as RGB, where (0, 0, 0) would be (0.5, 0.5, 0.5).\n\t\tfragColour = vec4((NORMAL.xyz * 0.5) + vec3(0.5), 1.0);\n\t}\n}'], GL_FRAGMENT_SHADER)
18:48:41, 01-10-2024 / ERROR in Main.py Value initialisation / ("Shader compile failure (0): b'0(19) : error C7554: OpenGL requires sampler variables to be explicitly declared as uniform\\n'", [b'#version 330 core\n\nin vec2 fragTexCoords;\nin vec3 fragNormal;\nin vec3 fragPos;\nin int fragSheetID;\n\nout vec4 fragColour;\n\nuniform vec3 CAMERA_POSITION;\nuniform vec3 CAMERA_LOOK_AT;\nuniform vec4 VOID_COLOUR;\nuniform float VIEW_MAX_DIST;\nuniform bool HEADLAMP_ENABLED;\nuniform bool NORMAL_DEBUG;\nuniform bool WIREFRAME_DEBUG;\n\nlayout(std140) uniform TEXTURE_IDs {\n    uniform sampler2D SHEETS[32];\n};\n\n\n//Mirrors the python equivalent class, bar a few unneccessary attributes.\nstruct LIGHT {\n\tvec3 POSITION;\n\tvec3 LOOK_AT;\n\tvec3 COLOUR;\n\tfloat INTENSITY;\n\tfloat FOV;\n\tfloat MAX_DIST;\n\tmat4 LIGHT_SPACE_MATRIX;\n\tsampler2D SHADOW_MAP;\n\tbool ENABLED;\n};\n\n//Maximum of 64 lights in a scene.\nuniform int LIGHT_COUNT;\nuniform LIGHT LIGHTS[64];\n\n\nfloat FIND_SHADOW(LIGHT LIGHT, vec3 LIGHT_DIRECTION, vec3 NORMAL, vec4 FRAGMENT_POSITION_LIGHT_SPACE, vec3 fragPos) {\n\t//Finds whether or not a fragPos should be in shadow or not, utilising the shadow map, and PCF.\n\n\tvec3 PROJECTED_COORDINATES = FRAGMENT_POSITION_LIGHT_SPACE.xyz / FRAGMENT_POSITION_LIGHT_SPACE.w;\n\tPROJECTED_COORDINATES = (PROJECTED_COORDINATES * 0.5) + 0.5; //Convert projected coordinates to [0.0 - 1.0] range to use as UV\n\n\t//Initialise values such as the mapping bias and whatnot.\n\tfloat SHADOW = 0.0;\n\tvec2 TEXEL_SIZE = 1.5 / textureSize(LIGHT.SHADOW_MAP, 0);\n\tfloat ACTUAL_DEPTH = length(LIGHT.POSITION - fragPos);\n\tif (ACTUAL_DEPTH > LIGHT.MAX_DIST) {\n\t\treturn 1.0;\n\t}\n\tfloat CURRENT_DEPTH = clamp(ACTUAL_DEPTH, LIGHT.MAX_DIST/100, LIGHT.MAX_DIST)/LIGHT.MAX_DIST; //0.0 is the light\'s position, 1.0 at the light\'s maximum distance. Linear.\n\tfloat MAPPING_BIAS = (-1.25e-2 * max(1.0 - dot(NORMAL, LIGHT_DIRECTION), 0.01)) - (2.5e-3 * dot(NORMAL, LIGHT_DIRECTION));\n\n\n\n\tint KERNEL_SIZE = 5; //5 appears to be a good value for this, not too extreme but also not too low.\n\t//Iterate over a square with KERNEL_SIZE "radius" to calculate PCF values.\n\tfor (int X = -KERNEL_SIZE; X <= KERNEL_SIZE; ++X) {\n\t\tfor (int Y = -KERNEL_SIZE; Y <= KERNEL_SIZE; ++Y) {\n\t\t\tfloat SHADOW_MAP_DEPTH = texture(LIGHT.SHADOW_MAP, PROJECTED_COORDINATES.xy + vec2(X, Y) * TEXEL_SIZE).r;\n\t\t\tSHADOW += ((CURRENT_DEPTH + MAPPING_BIAS) > SHADOW_MAP_DEPTH) ? 1.0 : 0.0;\n\t\t}\n\t}\n\n\t//Divide by the KERNEL_SIZE\'s created sample area, so that the value returned is in the [0.0 - 1.0] range again.\n\tSHADOW /= float((KERNEL_SIZE * 2 + 1) * (KERNEL_SIZE * 2 + 1));\n\treturn SHADOW;\n}\n\n\nvoid main() {\n\tif (WIREFRAME_DEBUG) {\n\t\tfragColour = vec4(1.0, 1.0, 1.0, 1.0);\n\t\treturn;\n\t}\n\n\t//Actual fragment depth.\n\tfloat FRAG_DEPTH = length(CAMERA_POSITION - fragPos);\n\tif (FRAG_DEPTH >= VIEW_MAX_DIST) {\n\t\tfragColour = VOID_COLOUR;\n\t\treturn;\n\t}\n\n\t//Initialise colours (texture and default final)\n\tvec4 TEXTURE_COLOUR = texture(SHEETS[fragSheetID], fragTexCoords);\n\tvec3 FINAL_COLOUR = vec3(0.05);\n\t\n\tif (fragNormal == vec3(0.0)) {\n\t\tfragColour = vec4(1.0, 1.0, 0.0, 1.0);\n\t\treturn;\n\t}\n\n\t//Assorted other fragment data.\n\tvec3 NORMAL = (gl_FrontFacing) ? normalize(fragNormal) : normalize(fragNormal) * -1;\n\tfloat DISTANCE_FADE = 1.0 - (FRAG_DEPTH / VIEW_MAX_DIST);\n\n\n\t//Iterate through each light and check if the fragment is within the light\'s FOV, then calculate brightness and colour impact of said light.\n\tfor (int I = 0; I < LIGHT_COUNT; I++) {\n\t\tif (!LIGHTS[I].ENABLED) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tfloat FRAG_LIGHT_DISTANCE = length(LIGHTS[I].POSITION - fragPos);\n\t\tvec3 LIGHT_DIRECTION = normalize(LIGHTS[I].LOOK_AT - fragPos); // Direction to the light\n\t\tvec3 LIGHT_FORWARD = normalize(LIGHTS[I].POSITION - LIGHTS[I].LOOK_AT); // Light\'s forward direction\n\n\t\t//Calculate the angle between the light direction and the light\'s forward direction\n\t\tfloat FOV_COS = dot(LIGHT_DIRECTION, LIGHT_FORWARD); //Dot product of normalized vectors\n\t\tif (degrees(acos(FOV_COS)) > (LIGHTS[I].FOV * 0.5)) {\n\t\t\t//If it\'s out of the light\'s FOV - do not account for this light\'s influence.\n\t\t\tcontinue;\n\t\t}\n\n\t\t//Calculate the angle between the light\'s directional vector and the view\'s surface normal\n\t\tfloat NORMAL_LIGHT_ANGLE = clamp(dot(NORMAL, LIGHT_DIRECTION), 0.0, 1.0);\n\t\t//Prevent excessive FOV values from messing with the rest of the light calculations (negative values, 0 values)\n\t\tif (NORMAL_LIGHT_ANGLE <= 0.01) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t//Calculate the fragPos in the light\'s space\n\t\tvec4 FRAGMENT_POSITION_LIGHT_SPACE = LIGHTS[I].LIGHT_SPACE_MATRIX * vec4(fragPos, 1.0);\n\n\t\t//Brightness component calculations.\n\t\tfloat ATTENUATION = max(0.0, 1.0 - (FRAG_LIGHT_DISTANCE / LIGHTS[I].MAX_DIST)); //"Distance fade from light".\n\t\tfloat DIFFUSE =  2.0 * FOV_COS * FOV_COS - 1.0; //Dimmer as you go further from the "centre" of the light\'s direction.\n\t\tfloat SHADOW = FIND_SHADOW(LIGHTS[I], LIGHT_DIRECTION, NORMAL, FRAGMENT_POSITION_LIGHT_SPACE, fragPos); //Fragment shadow or not.\n\t\tfloat BRIGHTNESS = clamp(ATTENUATION * LIGHTS[I].INTENSITY * DIFFUSE * (1.0 - SHADOW), 0.05, 1.0) * abs(NORMAL_LIGHT_ANGLE); //Combine all the rest into one.\n\n\t\t//Add this light\'s influence to the final colour.\n\t\tFINAL_COLOUR += vec3(TEXTURE_COLOUR.rgb * BRIGHTNESS);\n\t}\n\n\n\n\tif (HEADLAMP_ENABLED) {\n\t\t//If the player\'s headlamp is turned on, cast a light from the camera with fixed FOV/max dist, and no shadows\n\t\t//(Any shadows would simply be hidden from the player\'s view anyhow, and this saves performance.)\n\t\tvec4 HEADLAMP_COLOUR = vec4(1.0, 1.0, 1.0, 1.0); //R, G, B, Intensity.\n\t\tvec3 HEADLAMP_OFFSET = vec3(0.0, 0.0, 0.0);\n\t\tfloat HEADLAMP_MAX_DIST = 10.0;\n\t\tfloat HEADLAMP_FOV = 45.0;\n\n\t\tvec3 HEADLAMP_POSITION = CAMERA_POSITION + HEADLAMP_OFFSET; //Allows for an offset, if needed (Unlikely, but supported.)\n\n\n\n\t\tfloat FRAG_CAMERA_DISTANCE = length(HEADLAMP_POSITION - fragPos);\n\t\tvec3 FRAG_HEADLAMP_DIRECTION = normalize(HEADLAMP_POSITION - fragPos); // Direction to the light\n\t\tvec3 HEADLAMP_FORWARD = normalize(HEADLAMP_POSITION - CAMERA_LOOK_AT); // Light\'s forward direction\n\n\t\t//Calculate the angle between the light direction and the light\'s forward direction\n\t\tfloat FOV_COS = dot(FRAG_HEADLAMP_DIRECTION, HEADLAMP_FORWARD); //Dot product of normalized vectors\n\n\t\tif (degrees(acos(FOV_COS)) <= (HEADLAMP_FOV * 0.5)) {\n\t\t\t//Calculate the angle between the light\'s directional vector and the view\'s surface normal\n\t\t\tfloat NORMAL_LIGHT_ANGLE = clamp(dot(NORMAL, FRAG_HEADLAMP_DIRECTION), 0.0, 1.0);\n\n\t\t\t//Prevent excessive FOV values from messing with the rest of the light calculations (negative values, 0 values)\n\t\t\tif (NORMAL_LIGHT_ANGLE > 0.01) {\n\t\t\t\t//Brightness component calculations.\n\t\t\t\tfloat ATTENUATION = max(0.0, 1.0 - (FRAG_CAMERA_DISTANCE / HEADLAMP_MAX_DIST)); //"Distance fade from light".\n\t\t\t\tfloat DIFFUSE =  2.0 * FOV_COS * FOV_COS - 1.0; //Dimmer as you go further from the "centre" of the light\'s direction.\n\t\t\t\tfloat BRIGHTNESS = clamp(ATTENUATION * HEADLAMP_COLOUR.w * DIFFUSE, 0.05, 1.0) * abs(NORMAL_LIGHT_ANGLE); //Combine all the rest into one.\n\n\t\t\t\t//Add this light\'s influence to the final colour.\n\t\t\t\tFINAL_COLOUR += vec3(TEXTURE_COLOUR.rgb * BRIGHTNESS);\n\t\t\t}\n\t\t}\n\n\n\t}\n\n\n\n\tif (!NORMAL_DEBUG) {\n\t\t//Display final colour\n\t\tfragColour = vec4(FINAL_COLOUR * DISTANCE_FADE, TEXTURE_COLOUR.a);\n\t} else {\n\t\t//Display the surface normals as RGB, where (0, 0, 0) would be (0.5, 0.5, 0.5).\n\t\tfragColour = vec4((NORMAL.xyz * 0.5) + vec3(0.5), 1.0);\n\t}\n}'], GL_FRAGMENT_SHADER)
18:49:59, 01-10-2024 / ERROR in Main.py Value initialisation / BUFFERS_INIT() missing 1 required positional argument: 'TEXTURES'
18:51:06, 01-10-2024 / ERROR in Main.py Value initialisation / ("Shader compile failure (0): b'0(18) : error C7554: OpenGL requires sampler variables to be explicitly declared as uniform\\n'", [b'#version 330 core\n\nin vec2 fragTexCoords;\nin vec3 fragNormal;\nin vec3 fragPos;\nin int fragSheetID;\n\nout vec4 fragColour;\n\nuniform vec3 CAMERA_POSITION;\nuniform vec3 CAMERA_LOOK_AT;\nuniform vec4 VOID_COLOUR;\nuniform float VIEW_MAX_DIST;\nuniform bool HEADLAMP_ENABLED;\nuniform bool NORMAL_DEBUG;\nuniform bool WIREFRAME_DEBUG;\n\nsampler2D SHEETS[32];\n\n\n//Mirrors the python equivalent class, bar a few unneccessary attributes.\nstruct LIGHT {\n\tvec3 POSITION;\n\tvec3 LOOK_AT;\n\tvec3 COLOUR;\n\tfloat INTENSITY;\n\tfloat FOV;\n\tfloat MAX_DIST;\n\tmat4 LIGHT_SPACE_MATRIX;\n\tsampler2D SHADOW_MAP;\n\tbool ENABLED;\n};\n\n//Maximum of 64 lights in a scene.\nuniform int LIGHT_COUNT;\nuniform LIGHT LIGHTS[64];\n\n\nfloat FIND_SHADOW(LIGHT LIGHT, vec3 LIGHT_DIRECTION, vec3 NORMAL, vec4 FRAGMENT_POSITION_LIGHT_SPACE, vec3 fragPos) {\n\t//Finds whether or not a fragPos should be in shadow or not, utilising the shadow map, and PCF.\n\n\tvec3 PROJECTED_COORDINATES = FRAGMENT_POSITION_LIGHT_SPACE.xyz / FRAGMENT_POSITION_LIGHT_SPACE.w;\n\tPROJECTED_COORDINATES = (PROJECTED_COORDINATES * 0.5) + 0.5; //Convert projected coordinates to [0.0 - 1.0] range to use as UV\n\n\t//Initialise values such as the mapping bias and whatnot.\n\tfloat SHADOW = 0.0;\n\tvec2 TEXEL_SIZE = 1.5 / textureSize(LIGHT.SHADOW_MAP, 0);\n\tfloat ACTUAL_DEPTH = length(LIGHT.POSITION - fragPos);\n\tif (ACTUAL_DEPTH > LIGHT.MAX_DIST) {\n\t\treturn 1.0;\n\t}\n\tfloat CURRENT_DEPTH = clamp(ACTUAL_DEPTH, LIGHT.MAX_DIST/100, LIGHT.MAX_DIST)/LIGHT.MAX_DIST; //0.0 is the light\'s position, 1.0 at the light\'s maximum distance. Linear.\n\tfloat MAPPING_BIAS = (-1.25e-2 * max(1.0 - dot(NORMAL, LIGHT_DIRECTION), 0.01)) - (2.5e-3 * dot(NORMAL, LIGHT_DIRECTION));\n\n\n\n\tint KERNEL_SIZE = 5; //5 appears to be a good value for this, not too extreme but also not too low.\n\t//Iterate over a square with KERNEL_SIZE "radius" to calculate PCF values.\n\tfor (int X = -KERNEL_SIZE; X <= KERNEL_SIZE; ++X) {\n\t\tfor (int Y = -KERNEL_SIZE; Y <= KERNEL_SIZE; ++Y) {\n\t\t\tfloat SHADOW_MAP_DEPTH = texture(LIGHT.SHADOW_MAP, PROJECTED_COORDINATES.xy + vec2(X, Y) * TEXEL_SIZE).r;\n\t\t\tSHADOW += ((CURRENT_DEPTH + MAPPING_BIAS) > SHADOW_MAP_DEPTH) ? 1.0 : 0.0;\n\t\t}\n\t}\n\n\t//Divide by the KERNEL_SIZE\'s created sample area, so that the value returned is in the [0.0 - 1.0] range again.\n\tSHADOW /= float((KERNEL_SIZE * 2 + 1) * (KERNEL_SIZE * 2 + 1));\n\treturn SHADOW;\n}\n\n\nvoid main() {\n\tif (WIREFRAME_DEBUG) {\n\t\tfragColour = vec4(1.0, 1.0, 1.0, 1.0);\n\t\treturn;\n\t}\n\n\t//Actual fragment depth.\n\tfloat FRAG_DEPTH = length(CAMERA_POSITION - fragPos);\n\tif (FRAG_DEPTH >= VIEW_MAX_DIST) {\n\t\tfragColour = VOID_COLOUR;\n\t\treturn;\n\t}\n\n\t//Initialise colours (texture and default final)\n\tvec4 TEXTURE_COLOUR = texture(SHEETS[fragSheetID], fragTexCoords);\n\tvec3 FINAL_COLOUR = vec3(0.05);\n\t\n\tif (fragNormal == vec3(0.0)) {\n\t\tfragColour = vec4(1.0, 1.0, 0.0, 1.0);\n\t\treturn;\n\t}\n\n\t//Assorted other fragment data.\n\tvec3 NORMAL = (gl_FrontFacing) ? normalize(fragNormal) : normalize(fragNormal) * -1;\n\tfloat DISTANCE_FADE = 1.0 - (FRAG_DEPTH / VIEW_MAX_DIST);\n\n\n\t//Iterate through each light and check if the fragment is within the light\'s FOV, then calculate brightness and colour impact of said light.\n\tfor (int I = 0; I < LIGHT_COUNT; I++) {\n\t\tif (!LIGHTS[I].ENABLED) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tfloat FRAG_LIGHT_DISTANCE = length(LIGHTS[I].POSITION - fragPos);\n\t\tvec3 LIGHT_DIRECTION = normalize(LIGHTS[I].LOOK_AT - fragPos); // Direction to the light\n\t\tvec3 LIGHT_FORWARD = normalize(LIGHTS[I].POSITION - LIGHTS[I].LOOK_AT); // Light\'s forward direction\n\n\t\t//Calculate the angle between the light direction and the light\'s forward direction\n\t\tfloat FOV_COS = dot(LIGHT_DIRECTION, LIGHT_FORWARD); //Dot product of normalized vectors\n\t\tif (degrees(acos(FOV_COS)) > (LIGHTS[I].FOV * 0.5)) {\n\t\t\t//If it\'s out of the light\'s FOV - do not account for this light\'s influence.\n\t\t\tcontinue;\n\t\t}\n\n\t\t//Calculate the angle between the light\'s directional vector and the view\'s surface normal\n\t\tfloat NORMAL_LIGHT_ANGLE = clamp(dot(NORMAL, LIGHT_DIRECTION), 0.0, 1.0);\n\t\t//Prevent excessive FOV values from messing with the rest of the light calculations (negative values, 0 values)\n\t\tif (NORMAL_LIGHT_ANGLE <= 0.01) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t//Calculate the fragPos in the light\'s space\n\t\tvec4 FRAGMENT_POSITION_LIGHT_SPACE = LIGHTS[I].LIGHT_SPACE_MATRIX * vec4(fragPos, 1.0);\n\n\t\t//Brightness component calculations.\n\t\tfloat ATTENUATION = max(0.0, 1.0 - (FRAG_LIGHT_DISTANCE / LIGHTS[I].MAX_DIST)); //"Distance fade from light".\n\t\tfloat DIFFUSE =  2.0 * FOV_COS * FOV_COS - 1.0; //Dimmer as you go further from the "centre" of the light\'s direction.\n\t\tfloat SHADOW = FIND_SHADOW(LIGHTS[I], LIGHT_DIRECTION, NORMAL, FRAGMENT_POSITION_LIGHT_SPACE, fragPos); //Fragment shadow or not.\n\t\tfloat BRIGHTNESS = clamp(ATTENUATION * LIGHTS[I].INTENSITY * DIFFUSE * (1.0 - SHADOW), 0.05, 1.0) * abs(NORMAL_LIGHT_ANGLE); //Combine all the rest into one.\n\n\t\t//Add this light\'s influence to the final colour.\n\t\tFINAL_COLOUR += vec3(TEXTURE_COLOUR.rgb * BRIGHTNESS);\n\t}\n\n\n\n\tif (HEADLAMP_ENABLED) {\n\t\t//If the player\'s headlamp is turned on, cast a light from the camera with fixed FOV/max dist, and no shadows\n\t\t//(Any shadows would simply be hidden from the player\'s view anyhow, and this saves performance.)\n\t\tvec4 HEADLAMP_COLOUR = vec4(1.0, 1.0, 1.0, 1.0); //R, G, B, Intensity.\n\t\tvec3 HEADLAMP_OFFSET = vec3(0.0, 0.0, 0.0);\n\t\tfloat HEADLAMP_MAX_DIST = 10.0;\n\t\tfloat HEADLAMP_FOV = 45.0;\n\n\t\tvec3 HEADLAMP_POSITION = CAMERA_POSITION + HEADLAMP_OFFSET; //Allows for an offset, if needed (Unlikely, but supported.)\n\n\n\n\t\tfloat FRAG_CAMERA_DISTANCE = length(HEADLAMP_POSITION - fragPos);\n\t\tvec3 FRAG_HEADLAMP_DIRECTION = normalize(HEADLAMP_POSITION - fragPos); // Direction to the light\n\t\tvec3 HEADLAMP_FORWARD = normalize(HEADLAMP_POSITION - CAMERA_LOOK_AT); // Light\'s forward direction\n\n\t\t//Calculate the angle between the light direction and the light\'s forward direction\n\t\tfloat FOV_COS = dot(FRAG_HEADLAMP_DIRECTION, HEADLAMP_FORWARD); //Dot product of normalized vectors\n\n\t\tif (degrees(acos(FOV_COS)) <= (HEADLAMP_FOV * 0.5)) {\n\t\t\t//Calculate the angle between the light\'s directional vector and the view\'s surface normal\n\t\t\tfloat NORMAL_LIGHT_ANGLE = clamp(dot(NORMAL, FRAG_HEADLAMP_DIRECTION), 0.0, 1.0);\n\n\t\t\t//Prevent excessive FOV values from messing with the rest of the light calculations (negative values, 0 values)\n\t\t\tif (NORMAL_LIGHT_ANGLE > 0.01) {\n\t\t\t\t//Brightness component calculations.\n\t\t\t\tfloat ATTENUATION = max(0.0, 1.0 - (FRAG_CAMERA_DISTANCE / HEADLAMP_MAX_DIST)); //"Distance fade from light".\n\t\t\t\tfloat DIFFUSE =  2.0 * FOV_COS * FOV_COS - 1.0; //Dimmer as you go further from the "centre" of the light\'s direction.\n\t\t\t\tfloat BRIGHTNESS = clamp(ATTENUATION * HEADLAMP_COLOUR.w * DIFFUSE, 0.05, 1.0) * abs(NORMAL_LIGHT_ANGLE); //Combine all the rest into one.\n\n\t\t\t\t//Add this light\'s influence to the final colour.\n\t\t\t\tFINAL_COLOUR += vec3(TEXTURE_COLOUR.rgb * BRIGHTNESS);\n\t\t\t}\n\t\t}\n\n\n\t}\n\n\n\n\tif (!NORMAL_DEBUG) {\n\t\t//Display final colour\n\t\tfragColour = vec4(FINAL_COLOUR * DISTANCE_FADE, TEXTURE_COLOUR.a);\n\t} else {\n\t\t//Display the surface normals as RGB, where (0, 0, 0) would be (0.5, 0.5, 0.5).\n\t\tfragColour = vec4((NORMAL.xyz * 0.5) + vec3(0.5), 1.0);\n\t}\n}'], GL_FRAGMENT_SHADER)
18:51:21, 01-10-2024 / ERROR in Main.py Value initialisation / Validation failure (0): 
18:51:28, 01-10-2024 / ERROR in Main.py Value initialisation / argument 2: TypeError: wrong type
18:51:39, 01-10-2024 / ERROR in Main.py Value initialisation / argument 2: TypeError: wrong type
18:55:03, 01-10-2024 / ERROR in Main.py Value initialisation / argument 2: TypeError: wrong type
18:55:05, 01-10-2024 / ERROR in Main.py Value initialisation / argument 2: TypeError: wrong type
18:55:33, 01-10-2024 / ERROR in Main.py Value initialisation / argument 2: TypeError: wrong type
16:01:21, 02-10-2024 / ERROR in main.py / inconsistent use of tabs and spaces in indentation (texture_load.py, line 150)
18:39:03, 02-10-2024 / ERROR in ui.py // PROCESS_UI_STATE / argument 2: TypeError: wrong type
18:39:23, 02-10-2024 / ERROR in ui.py // PROCESS_UI_STATE / argument 2: TypeError: wrong type
18:50:43, 02-10-2024 / ERROR in scene.LOAD_FILE / module 'imgs.texture_load' has no attribute 'UI_CACHE_MANAGER'
18:51:43, 02-10-2024 / ERROR in texture_load.py // LOAD_SHEET / name 'SHEET_LIST' is not defined
18:52:35, 02-10-2024 / ERROR in texture_load.py // LOAD_SHEET / name 'SHEET_LIST' is not defined
18:52:58, 02-10-2024 / ERROR in texture_load.py // LOAD_SHEET / name 'SHEET' is not defined
19:12:13, 02-10-2024 / ERROR in texture_load.py // LOAD_SHEET / DATA must be a NumPy array.
19:12:46, 02-10-2024 / ERROR in texture_load.py // LOAD_SHEET / name 'FINAL_DATA' is not defined
19:14:08, 02-10-2024 / ERROR in main.py / expected an indented block after 'else' statement on line 148 (texture_load.py, line 151)
19:53:34, 02-10-2024 / ERROR in texture_load.TEXTURE_CACHE_MANAGER / invalid literal for int() with base 16: '>'
19:55:23, 02-10-2024 / ERROR in texture_load.UV_CACHE_MANAGER / invalid literal for int() with base 16: '>'
20:01:16, 02-10-2024 / ERROR in texture_load.UV_CACHE_MANAGER / string index out of range
20:01:28, 02-10-2024 / ERROR in texture_load.UV_CACHE_MANAGER / string index out of range
20:01:43, 02-10-2024 / ERROR in texture_load.UV_CACHE_MANAGER / string index out of range
20:02:29, 02-10-2024 / ERROR in texture_load.UV_CACHE_MANAGER / string index out of range
20:02:50, 02-10-2024 / ERROR in texture_load.UV_CACHE_MANAGER / string index out of range
20:06:29, 02-10-2024 / ERROR in texture_load.UV_CACHE_MANAGER / string index out of range
20:06:46, 02-10-2024 / ERROR in scene.LOAD_FILE / 'str' object cannot be interpreted as an integer
20:07:06, 02-10-2024 / ERROR in main.py / unexpected indent (scene.py, line 72)
20:07:16, 02-10-2024 / ERROR in main.py / unexpected indent (scene.py, line 72)
20:07:20, 02-10-2024 / ERROR in main.py / unexpected indent (scene.py, line 72)
20:07:48, 02-10-2024 / ERROR in texture_load.UV_CACHE_MANAGER / string index out of range
20:08:45, 02-10-2024 / ERROR in texture_load.UV_CACHE_MANAGER / string index out of range
20:09:21, 02-10-2024 / ERROR in texture_load.UV_CACHE_MANAGER / string index out of range
20:09:26, 02-10-2024 / ERROR in texture_load.UV_CACHE_MANAGER / invalid literal for int() with base 16: 'x'
20:10:09, 02-10-2024 / ERROR in texture_load.UV_CACHE_MANAGER / invalid literal for int() with base 16: 'x'
20:10:21, 02-10-2024 / ERROR in main.py / unexpected indent (texture_load.py, line 63)
20:11:20, 02-10-2024 / ERROR in render.OBJECT_VAO_MANAGER / list index out of range
20:32:45, 02-10-2024 / ERROR in physics.UPDATE_PHYSICS / 'VECTOR_3D' object has no attribute 'TO_LIST'
20:57:36, 02-10-2024 / ERROR in render.SCENE / OBJECT_VAO_MANAGER() missing 2 required positional arguments: 'TEXTURE_SHEETS_USED' and 'SHEETS_USED'
20:57:54, 02-10-2024 / ERROR in render.SCENE / OBJECT_VAO_MANAGER() missing 2 required positional arguments: 'TEXTURE_SHEETS_USED' and 'SHEETS_USED'
21:17:33, 02-10-2024 / ERROR in render.SCENE / OBJECT_VAO_MANAGER() missing 2 required positional arguments: 'TEXTURE_SHEETS_USED' and 'SHEETS_USED'
21:19:03, 02-10-2024 / ERROR in render.SCENE / OBJECT_VAO_MANAGER() missing 1 required positional argument: 'SHEETS_USED'
21:19:24, 02-10-2024 / ERROR in render.SCENE / 'str' object has no attribute 'X'
07:23:40, 03-10-2024 / ERROR in render.SCENE / 'str' object has no attribute 'X'
20:44:03, 03-10-2024 / ERROR in render.SCENE / 'str' object has no attribute 'X'
22:46:24, 03-10-2024 / ERROR in main.py / ':' expected after dictionary key (scene.py, line 56)
18:57:45, 04-10-2024 / ERROR in texture_load.py / invalid syntax (utils.py, line 1217)
18:57:58, 04-10-2024 / ERROR in texture_load.py / invalid syntax (utils.py, line 1217)
13:44:58, 05-10-2024 / ERROR in render.py / invalid syntax (ui.py, line 219)
13:49:59, 05-10-2024 / ERROR in ui.HUD / None
14:09:58, 05-10-2024 / ERROR in ui.HUD / tuple index out of range
16:26:30, 05-10-2024 / ERROR in ui.HUD / tuple index out of range
16:26:38, 05-10-2024 / ERROR in ui.HUD / tuple index out of range
16:27:26, 05-10-2024 / ERROR in ui.HUD / tuple index out of range
17:04:14, 05-10-2024 / ERROR in ui.HUD / tuple index out of range
18:34:35, 05-10-2024 / ERROR in scene.LOAD_FILE / 'list' object has no attribute 'strip'
18:57:07, 05-10-2024 / ERROR in texture_load.py // LOAD_SHEET / unhashable type: 'list'
18:57:25, 05-10-2024 / ERROR in texture_load.py // LOAD_SHEET / unhashable type: 'list'
19:11:30, 05-10-2024 / ERROR in physics.UPDATE_PHYSICS / dictionary changed size during iteration
19:12:15, 05-10-2024 / ERROR in physics.UPDATE_PHYSICS / dictionary changed size during iteration
19:23:59, 05-10-2024 / ERROR in ui.HUD / tuple index out of range
19:24:11, 05-10-2024 / ERROR in ui.HUD / tuple index out of range
19:36:46, 05-10-2024 / ERROR in ui.HUD / tuple index out of range
19:49:13, 05-10-2024 / ERROR in physics.UPDATE_PHYSICS / 17
21:07:24, 05-10-2024 / ERROR in ui.HUD / name 'I' is not defined
21:12:25, 05-10-2024 / ERROR in main.py / inconsistent use of tabs and spaces in indentation (physics.py, line 261)
21:12:35, 05-10-2024 / ERROR in main.py / inconsistent use of tabs and spaces in indentation (physics.py, line 261)
11:40:19, 06-10-2024 / ERROR in render.py / 'UI_RESOLUTION'
11:40:57, 06-10-2024 / ERROR in render.py / 'UI_RESOLUTION'
11:41:22, 06-10-2024 / ERROR in render.py / 'UI_RESOLUTION'
11:46:43, 06-10-2024 / ERROR in texture_load.py / expected ':' (utils.py, line 418)
11:46:58, 06-10-2024 / ERROR in render.OBJECT_VAO_MANAGER / 'NoneType' object has no attribute 'index'
14:38:32, 06-10-2024 / ERROR in scene.LOAD_FILE / list index out of range
14:39:01, 06-10-2024 / ERROR in scene.LOAD_FILE / list index out of range
14:39:31, 06-10-2024 / ERROR in main.py / unexpected indent (scene.py, line 77)
19:01:02, 08-10-2024 / ERROR in texture_load.py / unindent does not match any outer indentation level (render.py, line 478)
19:01:15, 08-10-2024 / ERROR in main.py / unindent does not match any outer indentation level (physics.py, line 138)
09:52:09, 10-10-2024 / ERROR in main.py / No module named 'numpy'
11:20:41, 10-10-2024 / ERROR in main.py / inconsistent use of tabs and spaces in indentation (texture_load.py, line 202)
11:21:06, 10-10-2024 / ERROR in main.py / inconsistent use of tabs and spaces in indentation (texture_load.py, line 202)
11:21:39, 10-10-2024 / ERROR in main.py / inconsistent use of tabs and spaces in indentation (texture_load.py, line 202)
19:51:09, 10-10-2024 / ERROR in render.py / 'VECTOR_2D' object has no attribute 'TO_LIST'
19:51:31, 10-10-2024 / ERROR in render.py / 'VECTOR_2D' object has no attribute 'TO_LIST'
19:51:42, 10-10-2024 / ERROR in arender.py / 'VECTOR_2D' object has no attribute 'TO_LIST'
19:52:07, 10-10-2024 / ERROR in render.py / 'VECTOR_2D' object has no attribute 'TO_LIST'
19:52:34, 10-10-2024 / ERROR in texture_load.py / 'VECTOR_2D' object has no attribute 'TO_LIST'
19:52:53, 10-10-2024 / ERROR in main.py / 'VECTOR_2D' object has no attribute 'TO_LIST'
20:47:50, 10-10-2024 / ERROR in ui.py // PROCESS_UI_STATE / 'VECTOR_2D' object has no attribute 'TO_INT'
20:48:54, 10-10-2024 / ERROR in ui.py // PROCESS_UI_STATE / 'VECTOR_2D' object has no attribute 'TO_INT'
20:49:36, 10-10-2024 / ERROR in ui.py // PROCESS_UI_STATE / __int__ returned non-int (type NoneType)
20:50:45, 10-10-2024 / ERROR in ui.py // PROCESS_UI_STATE / __int__ returned non-int (type VECTOR_2D)
20:21:22, 11-10-2024 / ERROR in render.OBJECT_VAO_MANAGER / 'str' object has no attribute 'X'
20:25:22, 11-10-2024 / ERROR in render.SCENE / 'str' object has no attribute 'X'
20:28:38, 11-10-2024 / ERROR in texture_load.UV_CACHE_MANAGER / unhashable type: 'VECTOR_2D'
20:28:55, 11-10-2024 / ERROR in texture_load.UV_CACHE_MANAGER / unhashable type: 'VECTOR_2D'
20:29:12, 11-10-2024 / ERROR in texture_load.UV_CACHE_MANAGER / unhashable type: 'VECTOR_2D'
15:59:28, 12-10-2024 / ERROR in texture_load.UV_CACHE_MANAGER / unhashable type: 'VECTOR_2D'
15:59:59, 12-10-2024 / ERROR in main.py / unexpected indent (texture_load.py, line 63)
16:53:17, 12-10-2024 / ERROR in render.py / expected ':' (physics.py, line 205)
21:45:29, 12-10-2024 / ERROR in render.py / expected ':' (physics.py, line 210)
11:01:36, 13-10-2024 / ERROR in texture_load.py / '(' was never closed (render.py, line 456)
22:25:02, 17-10-2024 / ERROR in ui.HUD / size needs to be (number width, number height)
22:36:17, 17-10-2024 / ERROR in ui.HUD / name 'SCREEN' is not defined
22:36:37, 17-10-2024 / ERROR in ui.HUD / name 'COLOURED_VIGNETTE' is not defined
22:37:38, 17-10-2024 / ERROR in render.py / name 'UPDATE_VIGNETTE' is not defined
22:37:48, 17-10-2024 / ERROR in render.py / local variable 'VIGNETTE_FADEOUT_CURRENT' referenced before assignment
22:38:09, 17-10-2024 / ERROR in render.py / local variable 'VIGNETTE_FADEOUT_CURRENT' referenced before assignment
22:39:40, 17-10-2024 / ERROR in ui.HUD / name 'COLOURED_VIGNETTE' is not defined
22:42:18, 17-10-2024 / ERROR in ui.HUD / name 'COLOURED_VIGNETTE' is not defined
22:43:06, 17-10-2024 / ERROR in ui.HUD / name 'COLOURED_VIGNETTE' is not defined
15:41:55, 18-10-2024 / ERROR in ui.py // PROCESS_UI_STATE / name 'COLOURED_VIGNETTE' is not defined
15:51:00, 18-10-2024 / ERROR in ui.py // PROCESS_UI_STATE / name 'COLOURED_VIGNETTE' is not defined
15:54:44, 18-10-2024 / ERROR in ui.py // PROCESS_UI_STATE / name 'COLOURED_VIGNETTE' is not defined
16:20:48, 18-10-2024 / ERROR in ui.py // PROCESS_UI_STATE / module 'exct.utils' has no attribute 'RESET_PLAYER'
16:21:33, 18-10-2024 / ERROR in ui.py // PROCESS_UI_STATE / module 'exct.utils' has no attribute 'RESET_PLAYER'
16:41:53, 18-10-2024 / ERROR in ui.py // PROCESS_UI_STATE / name 'OPTIONS_MENU_BUTTONS' is not defined
19:56:33, 18-10-2024 / ERROR in texture_load.py / '<' not supported between instances of 'int' and 'str'
19:56:39, 18-10-2024 / ERROR in texture_load.py / '<' not supported between instances of 'int' and 'str'
20:07:54, 18-10-2024 / ERROR in main.py / '<' not supported between instances of 'int' and 'str'
21:22:29, 18-10-2024 / ERROR in render.py / invalid syntax. Perhaps you forgot a comma? (ui.py, line 208)
21:41:31, 18-10-2024 / ERROR in ui.HUD / argument 1 must be pygame.surface.Surface, not None
21:38:51, 19-10-2024 / ERROR in ui.HUD / 'DEV_HIDE_HUD'
09:31:55, 20-10-2024 / ERROR in render.py / No module named 'PIL'
09:52:36, 20-10-2024 / ERROR in render.py / expected 'else' after 'if' expression (scene.py, line 317)
09:53:45, 20-10-2024 / ERROR in ui.HUD / 'NoneType' object is not subscriptable
09:55:32, 20-10-2024 / ERROR in render.py / invalid syntax (scene.py, line 316)
09:55:43, 20-10-2024 / ERROR in render.py / invalid syntax (scene.py, line 316)
11:38:06, 20-10-2024 / ERROR in render.py / inconsistent use of tabs and spaces in indentation (physics.py, line 185)
11:38:14, 20-10-2024 / ERROR in render.py / inconsistent use of tabs and spaces in indentation (physics.py, line 185)
11:38:20, 20-10-2024 / ERROR in render.py / inconsistent use of tabs and spaces in indentation (physics.py, line 185)
17:01:52, 20-10-2024 / ERROR in main.py / unindent does not match any outer indentation level (texture_load.py, line 62)
17:02:05, 20-10-2024 / ERROR in render.py / unindent does not match any outer indentation level (ui.py, line 296)
17:02:20, 20-10-2024 / ERROR in render.py / unindent does not match any outer indentation level (scene.py, line 77)