"""
[physics.py]
Controls the physics of the game, such as gravity and collisions.
Basic systems, not too complex for performance and ease-of-use reasons.

______________________
Importing other files;
-render.py
-physics.py
-texture_load.py
-load_scene.py
-log.py
-utils.py
"""
import sys, copy
import math as maths
from exct import log, utils, render
from scenes import scene
from exct.utils import *


sys.path.append("modules.zip")
import pygame as PG
from pygame.locals import *
from pygame import *
import numpy as NP

print("Imported Sub-file // physics.py")

PREFERENCES, CONSTANTS = utils.PREFERENCES, utils.CONSTANTS
e = maths.e
π = maths.pi
πDIV2 = π / 2



#General Physics Functions



def AIR_RES_CALC(VELOCITY_VECTOR): #Causes extreme slowdowns? also causes issues when velocity is near 0. Temporarily replaced by a flat x0.975 multiplier, via Prefs.
	#It seems that by "temporarily", I meant closer to 3 months. Oops?
	PROCESSED_VELOCITY = []
	for COMPONENT in VELOCITY_VECTOR:
		if COMPONENT >= 0:
			PROCESSED_VELOCITY.append((COMPONENT / 0.0000154) ** (0.3333333))
		
		else:
			PROCESSED_VELOCITY.append(-1*(abs(COMPONENT) / 0.0000154) ** (0.3333333))
	
	return PROCESSED_VELOCITY



def ACCELERATION_CALC(FORCE, MASS):
	"""
	F = ma
	Therefore a = F/m
	If Mass == 0 or Force == 0, then it will raise a zero-div-error.
	I account for this via presuming a "safe" return value is 0us^-2.
	"""
	if MASS <= 0:
				raise ValueError(f"Mass cannot be <= 0; {MASS}")
	try:
		return FORCE/MASS

	except ZeroDivisionError:
		return 0



def PLAYER_MOVEMENT(KEY_STATES, PLAYER):
	FINAL_MOVE_SPEED = CONSTANTS["PLAYER_SPEED_MOVE"]
	if KEY_STATES[PG.K_LCTRL]:
		FINAL_MOVE_SPEED *= CONSTANTS["MULT_CROUCH"]
	if KEY_STATES[PG.K_LSHIFT]:
		FINAL_MOVE_SPEED *= CONSTANTS["MULT_RUN"]
	elif KEY_STATES[PG.K_x]:
		FINAL_MOVE_SPEED *= CONSTANTS["MULT_SLOWWALK"]

	FINAL_MOVE_SPEED /= CONSTANTS["PHYSICS_ITERATIONS"]

	X_RADIANS = maths.radians(PLAYER.ROTATION.X)

	FORWARD = VECTOR_3D(
		-maths.cos(X_RADIANS),
		0,
		-maths.sin(X_RADIANS)
	)
	
	LEFT = VECTOR_3D(
		maths.sin(X_RADIANS),
		0,
		-maths.cos(X_RADIANS)
	)

	if KEY_STATES[PG.K_w]:
		PLAYER.POSITION += FORWARD * FINAL_MOVE_SPEED
	if KEY_STATES[PG.K_s]:
		PLAYER.POSITION -= FORWARD * FINAL_MOVE_SPEED
	if KEY_STATES[PG.K_a]:
		PLAYER.POSITION += LEFT * (-1 * FINAL_MOVE_SPEED)
	if KEY_STATES[PG.K_d]:
		PLAYER.POSITION -= LEFT * (-1 * FINAL_MOVE_SPEED)

	return PLAYER.POSITION



def UPDATE_PHYSICS(PHYS_DATA, FPS, KEY_STATES):
	#Updates the physics of the system once per frame.
	KINETICs_LIST, STATICs_LIST = PHYS_DATA
				
	HEIGHT_CHANGE = VECTOR_3D(0.0, 0.75, 0.0)
	BLANK_VECTOR = VECTOR_3D(0.0, 0.0, 0.0)

	for _ in range(CONSTANTS["PHYSICS_ITERATIONS"]):
		for PHYS_OBJECT_ID, PHYS_OBJECT in KINETICs_LIST.items():
			COLLIDING, DISPLACEMENT_VECTOR, TOUCHING = False, VECTOR_3D(0, 0, 0), False
			OBJECT_TYPE = type(PHYS_OBJECT)

				
			if OBJECT_TYPE == PLAYER:
				PHYS_OBJECT.POSITION = PLAYER_MOVEMENT(KEY_STATES, PHYS_OBJECT)

				PHYS_OBJECT.POINTS = utils.FIND_CUBOID_POINTS(CONSTANTS["PLAYER_COLLISION_CUBOID"], PHYS_OBJECT.POSITION)

				if KEY_STATES[PG.K_LCTRL]:
					KEY_STATES["CROUCH"] = True
					PHYS_OBJECT.POINTS += [
							PHYS_OBJECT.POINTS[0],
							PHYS_OBJECT.POINTS[1],
							PHYS_OBJECT.POINTS[2],
							PHYS_OBJECT.POINTS[3],
							PHYS_OBJECT.POINTS[4] - HEIGHT_CHANGE,
							PHYS_OBJECT.POINTS[5] - HEIGHT_CHANGE,
							PHYS_OBJECT.POINTS[6] - HEIGHT_CHANGE,
							PHYS_OBJECT.POINTS[7] - HEIGHT_CHANGE
						]

				elif not KEY_STATES[PG.K_LCTRL] and KEY_STATES["CROUCH"]:
					KEY_STATES["CROUCH"] = False
					PHYS_OBJECT.POINTS = [
							PHYS_OBJECT.POINTS[0],
							PHYS_OBJECT.POINTS[1],
							PHYS_OBJECT.POINTS[2],
							PHYS_OBJECT.POINTS[3],
							PHYS_OBJECT.POINTS[4] + HEIGHT_CHANGE,
							PHYS_OBJECT.POINTS[5] + HEIGHT_CHANGE,
							PHYS_OBJECT.POINTS[6] + HEIGHT_CHANGE,
							PHYS_OBJECT.POINTS[7] + HEIGHT_CHANGE
						]

			#Collisions between physics-bodies (not itself, hence the comparing of IDs)
			for BODY_ID, BODY in KINETICs_LIST.items():
				if BODY_ID != PHYS_OBJECT_ID: #Stops self collisions.
					if BOUNDING_BOX_COLLISION(PHYS_OBJECT.BOUNDING_BOX, BODY.BOUNDING_BOX):
						COLLISION_DATA = COLLISION_CHECK(PHYS_OBJECT, BODY)
						if COLLISION_DATA[2]:
							TOUCHING = True

						if COLLISION_DATA[0]:
							COLLIDING = True
							HALF_DISPLACEMENT = COLLISION_DATA[1] * 0.5
							HALF_DISPLACEMENT.Y = 0

							DISPLACEMENT_VECTOR += HALF_DISPLACEMENT
							BODY.POSITION -= HALF_DISPLACEMENT

							if OBJECT_TYPE == PLAYER:
								PHYS_OBJECT.POINTS = utils.FIND_CUBOID_POINTS(CONSTANTS["PLAYER_COLLISION_CUBOID"], PHYS_OBJECT.POSITION)
							elif OBJECT_TYPE in (ENEMY, ITEM,):
								PHYS_OBJECT.POINTS = utils.FIND_CUBOID_POINTS(PHYS_OBJECT.DIMENTIONS_3D, PHYS_OBJECT.POSITION)
							elif OBJECT_TYPE in (CUBE_PHYSICS,):
								PHYS_OBJECT.POINTS = utils.ROTATE_POINTS(utils.FIND_CUBOID_POINTS(PHYS_OBJECT.DIMENTIONS, PHYS_OBJECT.POSITION), PHYS_OBJECT.POSITION, PHYS_OBJECT.ROTATION)

			#Collisions between phys-body and environment
			for STATIC_ID, STATIC in STATICs_LIST[0].items(): #Check the statics (environmental objects) with collision only.
				if BOUNDING_BOX_COLLISION(PHYS_OBJECT.BOUNDING_BOX, STATIC.BOUNDING_BOX):
					COLLISION_DATA = COLLISION_CHECK(PHYS_OBJECT, STATIC)
					if COLLISION_DATA[2]:
						TOUCHING = True

					if COLLISION_DATA[0]:
						COLLIDING = True
						DISPLACEMENT_VECTOR += COLLISION_DATA[1] * 0.975
			


			if PHYS_OBJECT.POSITION.Y <= -256.0:
				PHYS_OBJECT.POSITION = VECTOR_3D(0.0, 0.0, 0.0)
				PHYS_OBJECT.LATERAL_VELOCITY.Y = 0.0

			elif COLLIDING:
				if OBJECT_TYPE == PLAYER:
					KEY_STATES["JUMP_GRACE"] = 0
				PHYS_OBJECT.POSITION += DISPLACEMENT_VECTOR
				PHYS_OBJECT.LATERAL_VELOCITY.Y = 0.0
				if TOUCHING:
					PHYS_OBJECT.LATERAL_VELOCITY *= CONSTANTS["MULT_FRICTION"]

			else:
				if KEY_STATES["JUMP_GRACE"] <= 10:
					KEY_STATES["JUMP_GRACE"] += 1
				try:
					GRAVITY_ACCEL = ACCELERATION_CALC(CONSTANTS["ACCEL_GRAV"]/FPS, CONSTANTS["PLAYER_MASS"]) / CONSTANTS["PHYSICS_ITERATIONS"]
				except ZeroDivisionError:
					GRAVITY_ACCEL = ACCELERATION_CALC(CONSTANTS["ACCEL_GRAV"]/PREFERENCES["FPS_LIMIT"], 10) / CONSTANTS["PHYSICS_ITERATIONS"]

				OBJECT_ACCELERATION = VECTOR_3D(0, GRAVITY_ACCEL, 0)
				PHYS_OBJECT.LATERAL_VELOCITY += OBJECT_ACCELERATION
				PHYS_OBJECT.POSITION += PHYS_OBJECT.LATERAL_VELOCITY / CONSTANTS["PHYSICS_ITERATIONS"]

			if (KEY_STATES[PG.K_SPACE]) and (OBJECT_TYPE == PLAYER) and (KEY_STATES["JUMP_GRACE"] <= 10):
				KEY_STATES[PG.K_SPACE] = False
				PHYS_OBJECT.LATERAL_VELOCITY.Y += CONSTANTS["JUMP_VELOCITY"]
				PHYS_OBJECT.POSITION += (PHYS_OBJECT.LATERAL_VELOCITY * (1 - (CONSTANTS["MULT_AIR_RES"] / CONSTANTS["PHYSICS_ITERATIONS"])))

			if OBJECT_TYPE == PLAYER:
				PHYS_OBJECT.POINTS = utils.FIND_CUBOID_POINTS(CONSTANTS["PLAYER_COLLISION_CUBOID"], PHYS_OBJECT.POSITION)
			elif OBJECT_TYPE in (ENEMY, ITEM,):
				PHYS_OBJECT.POINTS = utils.FIND_CUBOID_POINTS(PHYS_OBJECT.DIMENTIONS_3D, PHYS_OBJECT.POSITION)
			elif OBJECT_TYPE in (CUBE_PHYSICS,):
				PHYS_OBJECT.POINTS = utils.ROTATE_POINTS(utils.FIND_CUBOID_POINTS(PHYS_OBJECT.DIMENTIONS, PHYS_OBJECT.POSITION), PHYS_OBJECT.POSITION, PHYS_OBJECT.ROTATION)
			
			PHYS_OBJECT.BOUNDING_BOX.UPDATE(PHYS_OBJECT.POSITION, PHYS_OBJECT.POINTS)

			KINETICs_LIST[PHYS_OBJECT_ID] = PHYS_OBJECT


	PHYS_DATA = (KINETICs_LIST, STATICs_LIST)
	return PHYS_DATA
	
	#except Exception as E:
		#log.ERROR("physics.UPDATE_PHYSICS", E)




#Collision-checking functions


def BOUNDING_BOX_COLLISION(BOX_A, BOX_B):
	if ((BOX_A.MIN_X > BOX_B.MAX_X) or (BOX_A.MAX_X < BOX_B.MIN_X)
	  or (BOX_A.MIN_Y > BOX_B.MAX_Y) or (BOX_A.MAX_Y < BOX_B.MIN_Y)
	   or (BOX_A.MIN_Z > BOX_B.MAX_Z) or (BOX_A.MAX_Z < BOX_B.MIN_Z)):
		del BOX_A, BOX_B
		return False
	del BOX_A, BOX_B
	return True



def COLLISION_CHECK(PHYS_BODY, OBJECT):
	COLLIDING, TOUCHING = False, False
	APPLIED_VECTOR, PEN_DEPTH = VECTOR_3D(0, 0, 0), float("inf")
	OBJECT_TYPE = type(OBJECT)
	
	if OBJECT_TYPE in (CUBE_STATIC, CUBE_PATH, CUBE_PHYSICS):#Cubelike objects
		CLOSEST_FACE, NORMAL = utils.FIND_CLOSEST_CUBE_TRIS(OBJECT, PHYS_BODY)
		for TRIANGLE in CLOSEST_FACE:
			QUAD_COLLISION = CUBOID_TRI_COLLISION_DTEC(PHYS_BODY.POINTS, TRIANGLE, NORMAL) #The normals may be incorrect
			if QUAD_COLLISION[0]:
				PEN_DEPTH = min(QUAD_COLLISION[1], PEN_DEPTH)
				APPLIED_VECTOR += PEN_DEPTH * NORMAL
				COLLIDING = True
		
		return (COLLIDING, APPLIED_VECTOR, TOUCHING)
	
	elif OBJECT_TYPE in (QUAD, INTERACTABLE,):#Quadlike Objects
		QUAD_POINTS = OBJECT.POINTS
		TRI_LIST = (
			[QUAD_POINTS[0], QUAD_POINTS[1], QUAD_POINTS[2]],
			[QUAD_POINTS[0], QUAD_POINTS[3], QUAD_POINTS[2]]
		)
		
		for I, TRIANGLE in enumerate(TRI_LIST):
			QUAD_COLLISION = CUBOID_TRI_COLLISION_DTEC(PHYS_BODY.POINTS, TRIANGLE, OBJECT.NORMALS[I])
			if QUAD_COLLISION[0]:
				PEN_DEPTH = min(QUAD_COLLISION[1], PEN_DEPTH)
				APPLIED_VECTOR += PEN_DEPTH * OBJECT.NORMALS[0]
				COLLIDING = True
		
		return (COLLIDING, APPLIED_VECTOR, TOUCHING)
	
	elif OBJECT_TYPE == TRI:#Only Tris are singular triangles.
		TRI_COLLISION = CUBOID_TRI_COLLISION_DTEC(PHYS_BODY.POINTS, OBJECT.POINTS, OBJECT.NORMALS)
		
		if TRI_COLLISION[0]:
			APPLIED_VECTOR = TRI_COLLISION[1] * OBJECT.NORMALS[0]
			COLLIDING = True
		
		return (COLLIDING, APPLIED_VECTOR, TRI_COLLISION[2])
	
	return (False, APPLIED_VECTOR, False)



def CUBOID_TRI_COLLISION_DTEC(CUBOID, TRI, TRI_NORMAL):
	SEPARATING_AXIS = (
		(CUBOID[1] - CUBOID[0]).NORMALISE(),
		(CUBOID[2] - CUBOID[0]).NORMALISE(),
		(CUBOID[4] - CUBOID[0]).NORMALISE(),
	
		(TRI[0] - TRI[1]).NORMALISE(),
		(TRI[0] - TRI[2]).NORMALISE(),
		TRI_NORMAL
	)

	MIN_PEN_DEPTH = float('inf')

	for CURRENT_AXIS in SEPARATING_AXIS:
		CUBOID_MIN_MAX = CURRENT_AXIS.PROJECT(CUBOID)
		TRI_MIN_MAX = CURRENT_AXIS.PROJECT(TRI)

		if CUBOID_MIN_MAX[1] < TRI_MIN_MAX[0] or CUBOID_MIN_MAX[0] > TRI_MIN_MAX[1]:
			del SEPARATING_AXIS, CUBOID_MIN_MAX, TRI_MIN_MAX, CURRENT_AXIS
			return (False, 0, False)
		
		# Calculate penetration depth for the current axis
		PEN_DEPTH = min(abs(CUBOID_MIN_MAX[1] - TRI_MIN_MAX[0]), abs(TRI_MIN_MAX[1] - CUBOID_MIN_MAX[0]))
		MIN_PEN_DEPTH = min(MIN_PEN_DEPTH, PEN_DEPTH)

	OFFSET = -0.01 if MIN_PEN_DEPTH > 0.0 else 0.01 if MIN_PEN_DEPTH < 0.0 else 0.0
	del SEPARATING_AXIS, CUBOID_MIN_MAX, TRI_MIN_MAX, CURRENT_AXIS

	PEN_DEPTH = round(MIN_PEN_DEPTH + OFFSET, 8)
	return (True, PEN_DEPTH, abs(PEN_DEPTH) <= 0.001)